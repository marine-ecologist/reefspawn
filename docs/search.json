[{"path":"https://marine-ecologist.github.io/reefspawn/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 reefspawn authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/articles/allee.html","id":"bleaching-scenario","dir":"Articles","previous_headings":"","what":"2024 “bleaching” scenario","title":"allee effects","text":"simulate 20 X 10m plot 40% cover:","code":"library(tidyverse) library(sf) library(tmap) library(reefspawn)  seedval = 321  coral_size_2024 <- simulate_coralsize(coralsize |> filter(year==2011),                                        distribution = \"rlnorm\",                                        ndraws = 2000,                                       seed = seedval)  sf_plot <- setplot(20,10) # default EPSG:3857 coralsizepredictions <- posterior_coral_predict(brm = brm_sizedistribution,                                                 newdata = coral_size_2024,                                                  seed = seedval)  communities <- simulate_community(setplot = sf_plot,                                   coralcover = 40,                                   size = coral_size_2024,                                   seed = seedval)  populations <- simulate_populations(setplot = sf_plot,                                     size = coral_size_2024,                                     community = communities,                                     return=\"sf\",                                     seed = seedval)   reproductive_populations <- simulate_spawning(populations = populations,                                         setplot = sf_plot,                                         seed = 123)   reproductive_populations_postbleaching <- simulate_bleaching(populations = reproductive_populations)    prebleachingplot <- map_populations(setplot = sf_plot,                 populations = reproductive_populations, # or reproductive output, same sf population                 interactive = FALSE) + tm_title(\"Pre-bleaching\")  postbleachingplot <- map_populations(setplot = sf_plot,                 populations = reproductive_populations_postbleaching, # or reproductive output, same sf population                 interactive = FALSE) + tm_title(\"Post-bleaching\")  tmap::tmap_arrange(prebleachingplot, postbleachingplot, ncol=1)"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/allee.html","id":"calculate-allee-effects-intercolony-distances","dir":"Articles","previous_headings":"","what":"Calculate allee effects (intercolony distances)","title":"allee effects","text":"Plot intraspecific distance matrix spatial connectivity (.e. distances colonies bleaching cartesian space)","code":"pre_bleaching_allee <- calculate_allee_effects(populations = reproductive_populations_postbleaching,                                                 metric = \"centroid_distance\",                                                label = \"pre-bleaching\")     post_bleaching_allee <- calculate_allee_effects(populations = reproductive_populations_postbleaching |> filter(status==\"unbleached\"),                                                  metric = \"centroid_distance\",                                                 label = \"post-bleaching\")  all_combined_allee <- rbind(pre_bleaching_allee, post_bleaching_allee) |>    mutate(status = factor(status, levels=c(\"pre-bleaching\", \"post-bleaching\")))     tm_shape(all_combined_allee) +   tm_lines(col=\"species\",            col.legend = tm_legend_hide(),            col.scale = tm_scale_categorical(values=sp_pal(), levels.drop=FALSE),            lwd=0.1) +   tm_facets_grid(columns=\"status\", rows=\"species\")"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/allee.html","id":"calculate-fertilisation-success","dir":"Articles","previous_headings":"","what":"Calculate fertilisation success","title":"allee effects","text":"Reproduce Fig 2b PNAS paper (check tail exponential decay later)","code":"# Fit non-linear curve: exponential decay model library(tidyverse)  # Input data df <- tibble::tibble(   distance = c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20),   fertilization = c(30.1, 23.86, 18.43, 14.23, 10.79, 8.11, 6.07, 4.54, 3.44, 2.46, 1.82) )  # Exponential decay fit exp_decay_fit <- nls(   fertilization ~ a * exp(b * distance) + c,   data = df,   start = list(a = 28, b = -0.2, c = 2) )  # Exponential plateau fit exp_plateau_fit <- nls(   fertilization ~ c + a * exp(-b * distance),   data = df,   start = list(a = 28, b = 0.2, c = 2) )  # Generate prediction curves distance_seq <- seq(0, 30, 0.1)  decay_curve <- tibble(   distance = distance_seq,   fertilization = predict(exp_decay_fit, newdata = tibble(distance = distance_seq)),   model = \"Exponential Decay\" )  plateau_curve <- tibble(   distance = distance_seq,   fertilization = predict(exp_plateau_fit, newdata = tibble(distance = distance_seq)),   model = \"Exponential Plateau\" )  # Combine curves curve_df <- bind_rows(decay_curve, plateau_curve)  # Plot ggplot(df, aes(distance, fertilization)) +   geom_point(size = 1.2, shape=21) +   geom_line(data = curve_df, aes(x = distance, y = fertilization, color = model), linewidth = 0.1, show.legend=FALSE) +   theme_bw() + ylim(0,35) +   labs(title = \"\", y = \"Fertilization (%)\", x = \"Intercolony distance (m)\")"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/allee.html","id":"quantify-allee-effects-acropora-hyacinthus","dir":"Articles","previous_headings":"","what":"Quantify allee effects (Acropora hyacinthus)","title":"allee effects","text":"Fit exponential decay distance data, map fertilisation success (.e. distance) single species- .hyacinthus  Summary statistics hyacinthus - 93.6% mortality, 6.7% survival - 180 colonies pre-bleaching, 12 colonies surviving - clear reduction intracolony distance (despite mass mortality) - impact fertilisation success (assuming homogeneity dispersal)","code":"# fit exponential decay to distance data all_combined_allee_fertilisation <- all_combined_allee |>     mutate(fertilisation_success = round(predict(exp_decay_fit, newdata = data.frame(distance = centroid_distance)), 2))  allee_hyacinthus <- all_combined_allee_fertilisation |>   dplyr::filter(species == \"Acropora hyacinthus\")       tm_shape(allee_hyacinthus) +   tm_lines(     col = \"fertilisation_success\",     col.scale = tm_scale_continuous(values=\"brewer.spectral\"),     #col.legend = tm_legend_hide(),     lwd = 0.1   ) +      tm_facets_grid(rows=\"status\") + tm_title(\"Acropora hyacinthus\") a <- reproductive_populations_postbleaching |>    filter(species == \"Acropora hyacinthus\") |>    filter(output > 0) |>    as.data.frame() |>    count(status) |>    mutate(prop = n / sum(n) * 100) |>    ggplot(aes(x = \"\", y = prop, fill = status)) +   geom_col(alpha = 0.3, color = \"black\", position = \"stack\", show.legend=FALSE) +   theme_minimal() +   ylab(\"Proportion (%)\") +   xlab(\"\") +   ggtitle(\"% mortality pre - post bleaching\")  +     theme(plot.title = element_text(size = 8)) +   scale_fill_manual(values=c(\"darksalmon\", \"darkturquoise\"))   b <- reproductive_populations_postbleaching |>            filter(species==\"Acropora hyacinthus\") |>            as.data.frame() |>            filter(output > 0) |>            count(status) |>            mutate(prop = n / sum(n) * 100) |>     ggplot(aes(x = status, y = n, fill = status)) +           geom_col(alpha=0.3, col=\"black\", show.legend=FALSE) +           theme_minimal() +           ylab(\"n colonies\") +           xlab(\"Status\") + ggtitle(\"n colonies per 10*20m2 plot\") +     theme(plot.title = element_text(size = 8)) +   scale_fill_manual(values=c(\"darksalmon\", \"darkturquoise\"))   c <- allee_hyacinthus |>            as.data.frame() |>           count(status) |>            mutate(prop = n / sum(n) * 100) |>            ggplot(aes(x = status, y = n, fill = status)) +           geom_col(alpha=0.3, col=\"black\", show.legend=FALSE) +           theme_minimal() +           ylab(\"n\") +           xlab(\"Status\") +            ggtitle(\"Number of intercolony connections\") +     theme(plot.title = element_text(size = 8)) +   scale_fill_manual(values=c( \"darkturquoise\",  \"darksalmon\"))               d <-   ggplot() + theme_minimal() + ggtitle(\"Fertilisation success pre/post bleaching\") +     geom_density(data = allee_hyacinthus,                  aes(fertilisation_success, color = status, fill = status),                   alpha = 0.3, show.legend = FALSE)  +     theme(plot.title = element_text(size = 8)) +    scale_fill_manual(values=c( \"darkturquoise\",  \"darksalmon\")) +    scale_color_manual(values=c( \"darkturquoise\",  \"darksalmon\"))          e <- ggplot() + theme_minimal() + ggtitle(\"Inter-colony distance pre/post bleaching\") +     geom_density(data = allee_hyacinthus,                  aes(centroid_distance, color = status, fill = status), alpha=0.3) +     theme(plot.title = element_text(size = 8)) +    scale_fill_manual(values=c( \"darkturquoise\",  \"darksalmon\"))+    scale_color_manual(values=c( \"darkturquoise\",  \"darksalmon\"))       library(patchwork)      (a+b)/(c+d+e)  + plot_annotation(title = 'Acropora hyacinthus')"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/allee.html","id":"quantify-allee-effects-goniastrea-pectinata","dir":"Articles","previous_headings":"","what":"Quantify allee effects (Goniastrea pectinata)","title":"allee effects","text":"Fit exponential decay distance data, map fertilisation success (.e. distance) G.pectinata  Summary statistics goniastrea - 93.6% mortality, 6.7% survival - 180 colonies pre-bleaching, 12 colonies surviving - clear reduction intracolony distance (despite mass mortality) - impact fertilisation success (assuming homogeneity dispersal)","code":"# fit exponential decay to distance data all_combined_allee_fertilisation <- all_combined_allee |>     mutate(fertilisation_success = round(predict(exp_decay_fit, newdata = data.frame(distance = centroid_distance)), 2))  allee_goniastrea <- all_combined_allee_fertilisation |>   dplyr::filter(species == \"Goniastrea pectinata\")       tm_shape(allee_goniastrea) +   tm_lines(     col = \"fertilisation_success\",     col.scale = tm_scale_continuous(values=\"brewer.spectral\"),     #col.legend = tm_legend_hide(),     lwd = 0.1   ) +      tm_facets_grid(rows=\"status\") + tm_title(\"Goniastrea pectinata\") a <- reproductive_populations_postbleaching |>    filter(species == \"Goniastrea pectinata\") |>    filter(output > 0) |>    as.data.frame() |>    count(status) |>    mutate(prop = n / sum(n) * 100) |>    ggplot(aes(x = \"\", y = prop, fill = status)) +   geom_col(alpha = 0.3, color = \"black\", position = \"stack\", show.legend=FALSE) +   theme_minimal() +   ylab(\"Proportion (%)\") +   xlab(\"\") +   ggtitle(\"% mortality pre - post bleaching\")  +     theme(plot.title = element_text(size = 8)) +   scale_fill_manual(values=c(\"darksalmon\", \"darkturquoise\"))   b <- reproductive_populations_postbleaching |>            filter(species==\"Goniastrea pectinata\") |>            as.data.frame() |>            filter(output > 0) |>            count(status) |>            mutate(prop = n / sum(n) * 100) |>     ggplot(aes(x = status, y = n, fill = status)) +           geom_col(alpha=0.3, col=\"black\", show.legend=FALSE) +           theme_minimal() +           ylab(\"n colonies\") +           xlab(\"Status\") + ggtitle(\"n colonies per 10*20m2 plot\") +     theme(plot.title = element_text(size = 8)) +   scale_fill_manual(values=c(\"darksalmon\", \"darkturquoise\"))   c <- allee_goniastrea |>            as.data.frame() |>           count(status) |>            mutate(prop = n / sum(n) * 100) |>            ggplot(aes(x = status, y = n, fill = status)) +           geom_col(alpha=0.3, col=\"black\", show.legend=FALSE) +           theme_minimal() +           ylab(\"n\") +           xlab(\"Status\") +            ggtitle(\"Number of intercolony connections\") +     theme(plot.title = element_text(size = 8)) +   scale_fill_manual(values=c( \"darkturquoise\",  \"darksalmon\"))               d <-   ggplot() + theme_minimal() + ggtitle(\"Fertilisation success pre/post bleaching\") +     geom_density(data = allee_goniastrea,                  aes(fertilisation_success, color = status, fill = status),                   alpha = 0.3, show.legend = FALSE)  +     theme(plot.title = element_text(size = 8)) +    scale_fill_manual(values=c( \"darkturquoise\",  \"darksalmon\")) +    scale_color_manual(values=c( \"darkturquoise\",  \"darksalmon\"))          e <- ggplot() + theme_minimal() + ggtitle(\"Inter-colony distance pre/post bleaching\") +     geom_density(data = allee_goniastrea,                  aes(centroid_distance, color = status, fill = status), alpha=0.3) +     theme(plot.title = element_text(size = 8)) +    scale_fill_manual(values=c( \"darkturquoise\",  \"darksalmon\"))+    scale_color_manual(values=c( \"darkturquoise\",  \"darksalmon\"))       library(patchwork)      (a+b)/(c+d+e) + plot_annotation(title = 'Goniastrea pectinata')"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/allee.html","id":"summary-allee-effects","dir":"Articles","previous_headings":"","what":"Summary allee effects","title":"allee effects","text":"Mass reduction colony densities post-bleaching, yet minimal reduction intercolony distance / fertilisation success impact low 0.5 colonies per m2 (impact rare taxa (either post-bleaching losses threshold initially rare species)","code":"tmp <- reproductive_populations_postbleaching |>    filter(output > 0) |>    as.data.frame() |>    count(species, status) |>    mutate(n = n / 120) |>    pivot_wider(names_from=\"status\", values_from=\"n\") |>    mutate(prop = bleached/(bleached+unbleached)  * 100)   allee1 <- ggplot() + theme_bw() +    geom_point(data = tmp, aes(bleached, unbleached, fill=species), shape=21, size=1.5, show.legend=FALSE) +  #  ggrepel::geom_text_repel(data = tmp, aes(bleached, unbleached, label=species), max.overlaps=100) +    scale_x_continuous(limits=c(0,1.6), breaks = seq(0,1.6,0.4)) +    scale_y_continuous(limits=c(0,1.6), breaks = seq(0,1.6,0.4)) +   geom_abline(alpha=0.4) +    xlab(\"pre-bleaching\") +    ylab(\"post-bleaching\") +    ggtitle(\"Colony density (n/m2)\") +    theme(plot.title = element_text(size = 8))   tmp2 <- all_combined_allee_fertilisation |>    as.data.frame() |>    select(species, status, centroid_distance) |>    group_by(species, status) |>    summarise(distance = mean(centroid_distance)) |>    pivot_wider(names_from=\"status\", values_from=\"distance\") |>    rename(pre_bleaching = 2, post_bleaching =3)      allee2 <- ggplot() + theme_bw() +    geom_point(data = tmp2, aes(pre_bleaching, post_bleaching, fill=species), shape=21, size=1.5, show.legend=FALSE) +  #  ggrepel::geom_text_repel(data = tmp, aes(bleached, unbleached, label=species), max.overlaps=100) +    scale_x_continuous(limits=c(0,16), breaks = seq(0,16,4)) +    scale_y_continuous(limits=c(0,16), breaks = seq(0,16,4)) +   geom_abline(alpha=0.4) +    xlab(\"pre-bleaching\") +    ylab(\"post-bleaching\") +    ggtitle(\"Intercolony distance (m)\") +    theme(plot.title = element_text(size = 8))   tmp3 <- all_combined_allee_fertilisation |>    as.data.frame() |>    select(species, status, fertilisation_success) |>    group_by(species, status) |>    summarise(distance = mean(fertilisation_success)) |>    pivot_wider(names_from=\"status\", values_from=\"distance\") |>    rename(pre_bleaching = 2, post_bleaching =3)    allee3 <- ggplot() + theme_bw() +    geom_point(data = tmp3, aes(pre_bleaching, post_bleaching, fill=species), shape=21, size=1.5, show.legend=FALSE) +  #  ggrepel::geom_text_repel(data = tmp, aes(bleached, unbleached, label=species), max.overlaps=100) +    scale_x_continuous(limits=c(0,16), breaks = seq(0,16,4)) +    scale_y_continuous(limits=c(0,16), breaks = seq(0,16,4)) +   geom_abline(alpha=0.4) +    xlab(\"pre-bleaching\") +    ylab(\"post-bleaching\") +    ggtitle(\"Fertilisation success (%)\") +    theme(plot.title = element_text(size = 8))    summary_allee <- left_join(tmp, tmp2)    allee4 <- ggplot() + theme_bw() +    geom_point(data = summary_allee, aes(prop, post_bleaching, fill=species), shape=21, size=1.5, show.legend=FALSE) +  #  ggrepel::geom_text_repel(data = tmp, aes(bleached, unbleached, label=species), max.overlaps=100) +    geom_abline(alpha=0.4) +    xlab(\"% mortality\")+    ylab(\"Intercolony distance\") +    ggtitle(\"Post-bleaching intercolony distance\") +    theme(plot.title = element_text(size = 8))  (allee1 + allee2) / (allee3 + allee4)"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/brms.html","id":"parameter-estimates","dir":"Articles","previous_headings":"","what":"1. Parameter estimates","title":"Bayesian models","text":"data sourced Lizard Island corals via Álvarez-Noriega et al 2016 Madin et al 2023. Main data available package coralsize:  Data subset 2011 (last datapoint) predict size distributions: plot fitted distributions (yellow) raw data:  Predict total number oocytes per species * size: Extract conditional effects:  Predict probability fecundity per species (binary depending colony size: Extract conditional effects:  Predict probability density polyps per cm^2 per species: Extract conditional effects:  Predict proportion coral area reproductive (within sterile growth zone borders):","code":"library(tidyverse) library(forcats) library(units) library(ggplot2) library(fGarch) library(brms)   sp_order <- c(\"Acropora hyacinthus\", \"Acropora cytherea\",               \"Acropora intermedia\", \"Acropora robusta\",                 \"Acropora millepora\", \"Acropora nasuta\", \"Acropora spathulata\",                   \"Acropora humilis\", \"Acropora cf. digitifera\",                \"Goniastrea pectinata\", \"Goniastrea retiformis\")   sp_pal <- c(\"Acropora hyacinthus\" = \"#50676c\", \"Acropora cytherea\" = \"#3a6c8e\",   \"Acropora intermedia\" = \"#2c3687\", \"Acropora robusta\" = \"#7b8ca8\",     \"Acropora spathulata\" = \"#98a062\", \"Acropora millepora\" = \"#665a43\", \"Acropora nasuta\" =  \"#48642f\",       \"Acropora humilis\" = \"#824b3b\", \"Acropora cf. digitifera\" = \"#a47c73\",    \"Goniastrea pectinata\" = \"#999999\", \"Goniastrea retiformis\"= \"#bfbfbf\")  make_paler <- function(color) {   grDevices::adjustcolor(color, alpha.f = 1, red.f = 1.2, green.f = 1.2, blue.f = 1.2) }  # Apply the function to the palette sp_pal <- sapply(sp_pal, make_paler)   size_data <- coralsize |>    mutate(width=sqrt(area_cm2/pi)*2) |>    mutate(species=as.factor(species)) |>    mutate(species=fct_relevel(species,sp_order)) |>    mutate(growthform=fct_recode(species, \"Tabular\"= \"Acropora cytherea\", \"Tabular\"= \"Acropora hyacinthus\",                                          \"Branching\"= \"Acropora intermedia\", \"Branching\"= \"Acropora robusta\",                                         \"Massive\" = \"Goniastrea pectinata\", \"Massive\" = \"Goniastrea retiformis\",                                         \"Corymbose\" = \"Acropora nasuta\", \"Corymbose\" = \"Acropora millepora\", \"Corymbose\" = \"Acropora spathulata\",                                         \"Digitate\" = \"Acropora cf. digitifera\", \"Digitate\" = \"Acropora humilis\"))     ggplot() + theme_bw() + facet_wrap(~growthform, scales=\"free\") +   geom_density(data=size_data, aes(width, fill=species, color=species), alpha=0.3, linewidth=0.6, show.legend=TRUE) +   theme(panel.grid = element_blank()) + ylab(\"\") +   scale_color_manual(values=sp_pal) + scale_fill_manual(values=sp_pal) brm_sizedistribution <- brm(width ~ species,                             data = size_data |> filter(year==2011),                             family = Gamma(link = \"log\"),                             iter = 5000,                             chains = 4,                             cores = 12) fitted_vals <- fitted(brm_sizedistribution, scale = \"response\")  size_data <- size_data |> filter(year==2011) |> mutate(fitted = fitted(brm_sizedistribution, scale = \"response\")[, \"Estimate\"])  ggplot() + theme_bw() + facet_wrap(~species, scales = \"free\") +   geom_density(data = size_data, aes(x = width), fill = \"steelblue\", alpha = 0.5, show.legend=TRUE) +   geom_density(data = size_data, aes(x = fitted), fill = \"orange\", alpha = 0.4, show.legend=TRUE) +   labs(     x = \"Width\",     y = \"Density\",     title = \"Observed vs Predicted Distributions by Species\"   ) brm_fecundity <- brm(eggs ~ log(width)*species,                      cores = 12,                      chains=12,                      iter=4000,                      family = zero_inflated_poisson(),                      prior = c(prior(normal(1, 2), class = Intercept),                                 prior(beta(2, 2), class = zi)                                ),                      data = fecundity) brm_fecundity_cond <- conditional_effects(brm_fecundity, effects = \"width:species\", dpar = \"mu\") brm_fecundity_plots <- brm_fecundity_cond$`width:species` |> as.data.frame() %>%    mutate(species=fct_relevel(species,sp_order)) |>    mutate(growthform=fct_recode(species, \"Tabular\"= \"Acropora cytherea\", \"Tabular\"= \"Acropora hyacinthus\",                                          \"Branching\"= \"Acropora intermedia\", \"Branching\"= \"Acropora robusta\",                                         \"Massive\" = \"Goniastrea pectinata\", \"Massive\" = \"Goniastrea retiformis\",                                         \"Corymbose\" = \"Acropora nasuta\", \"Corymbose\" = \"Acropora millepora\",                                          \"Corymbose\" = \"Acropora spathulata\",                                         \"Digitate\" = \"Acropora cf. digitifera\", \"Digitate\" = \"Acropora humilis\"))  ggplot() + theme_bw() + facet_wrap(~growthform, scales=\"free_y\") + ylab(\"oocytes per polyp\") +   geom_line(data=brm_fecundity_plots, aes(width, estimate__, color=species), show.legend=TRUE) +   geom_ribbon(data=brm_fecundity_plots, aes(width, ymin=lower__, ymax=upper__, fill=species), alpha=0.2, show.legend=TRUE) +   scale_color_manual(values=sp_pal) + scale_fill_manual(values=sp_pal) brm_probability <- brm(reproductive ~ log(width) * species,                        cores = 12,                        chains = 12,                        iter = 4000,                        family = bernoulli(),                        data = fecundity) #| class-source: fold-hide #| message: false #| warning: false #| fig-width: 9.5 #| fig-height: 5  brm_probability_cond <- conditional_effects(brm_probability, effects = \"width:species\", dpar = \"mu\") brm_probability_plots <-  brm_probability_cond$`width:species` |> as.data.frame() %>%    mutate(growthform=fct_recode(species, \"Tabular\"= \"Acropora cytherea\", \"Tabular\"= \"Acropora hyacinthus\",                                          \"Branching\"= \"Acropora intermedia\", \"Branching\"= \"Acropora robusta\",                                         \"Massive\" = \"Goniastrea pectinata\", \"Massive\" = \"Goniastrea retiformis\",                                         \"Corymbose\" = \"Acropora nasuta\", \"Corymbose\" = \"Acropora millepora\", \"Corymbose\" = \"Acropora spathulata\",                                         \"Digitate\" = \"Acropora cf. digitifera\", \"Digitate\" = \"Acropora humilis\"))  ggplot() + theme_bw() + facet_wrap(~growthform, scales=\"free_y\") +   geom_line(data=brm_probability_plots, aes(width, estimate__, color=species), show.legend=TRUE) +   geom_ribbon(data=brm_probability_plots, aes(width, ymin=lower__, ymax=upper__, fill=species), alpha=0.2, show.legend=TRUE) +     scale_color_manual(values=sp_pal) + scale_fill_manual(values=sp_pal) +    ylab(\"Probability of reproductive colonies\") + xlab(\"Colony width\") brm_polyp_density <- brm(cm2 ~ species,                          family = gaussian,                          iter = 10000,                          chains = 8,                          cores = 11,                          data=polyp_density_data) # add a hack to get millepora, assume it's between millepora and nasuta millepora <- polyp_density_data |> filter(species==\"Acropora nasuta\" | species==\"Acropora spathulata\") |>                  mutate(species=\"Acropora millepora\") |>                  mutate(spp = \"AM\")  # rejoin polyp_density_data <- polyp_density_data |> rbind(millepora) |>    mutate(growthform=fct_recode(species, \"Tabular\"= \"Acropora cytherea\", \"Tabular\"= \"Acropora hyacinthus\",                                          \"Branching\"= \"Acropora intermedia\", \"Branching\"= \"Acropora robusta\",                                         \"Massive\" = \"Goniastrea pectinata\", \"Massive\" = \"Goniastrea retiformis\",                                         \"Corymbose\" = \"Acropora nasuta\", \"Corymbose\" = \"Acropora millepora\",                                          \"Corymbose\" = \"Acropora spathulata\",                                         \"Digitate\" = \"Acropora cf. digitifera\", \"Digitate\" = \"Acropora humilis\"))  ### data prep above for the brms model     brm_polyp_density_cond <- conditional_effects(brm_polyp_density, effects = \"species\", dpar = \"mu\")  brm_probability_plots <-  brm_polyp_density_cond$species |> as.data.frame() %>%    mutate(growthform=fct_recode(species, \"Tabular\"= \"Acropora cytherea\", \"Tabular\"= \"Acropora hyacinthus\",                                          \"Branching\"= \"Acropora intermedia\", \"Branching\"= \"Acropora robusta\",                                         \"Massive\" = \"Goniastrea pectinata\", \"Massive\" = \"Goniastrea retiformis\",                                         \"Corymbose\" = \"Acropora nasuta\", \"Corymbose\" = \"Acropora millepora\", \"Corymbose\" = \"Acropora spathulata\",                                         \"Digitate\" = \"Acropora cf. digitifera\", \"Digitate\" = \"Acropora humilis\"))  ggplot() + theme_bw() + facet_wrap(~growthform, scales=\"free\") +   geom_col(data=brm_probability_plots, aes(species, estimate__, fill=species),             color=\"black\", alpha=0.5, linewidth=0.5, show.legend=FALSE) +   geom_errorbar(data=brm_probability_plots, aes(species, estimate__, ymin=lower__, ymax=upper__, fill=species),                  width=0.05, color=\"black\", alpha=0.8, linewidth=0.5, show.legend=FALSE) +   theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=0.8)) +   scale_color_manual(values=sp_pal) + scale_fill_manual(values=sp_pal) +    ylab(bquote('Polyps per'*~cm^2*'')) + xlab(\"\") sterile_zone <- tibble(        species = c(\"Acropora hyacinthus\", \"Acropora cytherea\", \"Acropora cf. digitifera\",                    \"Acropora humilis\", \"Acropora nasuta\", \"Acropora spathulata\",                    \"Acropora millepora\",\"Acropora intermedia\",\"Acropora robusta\"),        lower__ = c(0.760, 0.999, 0.773, 0.995, 0.970, 0.885, 0.885, 0.760, 0.760),        median = c(0.771, 1.000, 0.868, 1.000, 0.999, 0.913, 0.913, 0.771, 0.771),        upper__ = c(0.781, 1.000, 0.936, 1.000, 1.000, 0.941, 0.941, 0.781, 0.781)         )  |>    mutate(growthform=fct_recode(species, \"Tabular\"= \"Acropora cytherea\", \"Tabular\"= \"Acropora hyacinthus\",                                          \"Branching\"= \"Acropora intermedia\", \"Branching\"= \"Acropora robusta\",                                         \"Corymbose\" = \"Acropora nasuta\", \"Corymbose\" = \"Acropora millepora\", \"Corymbose\" = \"Acropora spathulata\",                                         \"Digitate\" = \"Acropora cf. digitifera\", \"Digitate\" = \"Acropora humilis\")) |>    bind_rows(data.frame(species = c(\"Goniastrea retiformis\", \"Goniastrea pectinata\"),                                           lower__ = c(1,1),                                           median = c(1,1),                                           upper__ = c(1,1),                                           growthform = c(\"Massive\",\"Massive\")))  ggplot() + theme_bw() + facet_wrap(~growthform, scales=\"free_x\") +   geom_col(data=sterile_zone, aes(species, median*100, fill=species),             color=\"black\", alpha=0.3, linewidth=0.5, show.legend=FALSE) +   geom_errorbar(data=sterile_zone, aes(species, median*100, ymin=lower__*100, ymax=upper__*100),                  width=0.05, color=\"black\", alpha=0.8, linewidth=0.5, show.legend=FALSE) +    theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=0.8)) +   scale_color_manual(values=sp_pal) + scale_fill_manual(values=sp_pal) +    ylab(\"Proportion colony reproductive\") + xlab(\"\")"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/brms.html","id":"i--colony-size-distributions","dir":"Articles","previous_headings":"","what":"i. Colony size distributions","title":"Bayesian models","text":"Data subset 2011 (last datapoint) predict size distributions: plot fitted distributions (yellow) raw data:","code":"brm_sizedistribution <- brm(width ~ species,                             data = size_data |> filter(year==2011),                             family = Gamma(link = \"log\"),                             iter = 5000,                             chains = 4,                             cores = 12) fitted_vals <- fitted(brm_sizedistribution, scale = \"response\")  size_data <- size_data |> filter(year==2011) |> mutate(fitted = fitted(brm_sizedistribution, scale = \"response\")[, \"Estimate\"])  ggplot() + theme_bw() + facet_wrap(~species, scales = \"free\") +   geom_density(data = size_data, aes(x = width), fill = \"steelblue\", alpha = 0.5, show.legend=TRUE) +   geom_density(data = size_data, aes(x = fitted), fill = \"orange\", alpha = 0.4, show.legend=TRUE) +   labs(     x = \"Width\",     y = \"Density\",     title = \"Observed vs Predicted Distributions by Species\"   )"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/brms.html","id":"ii--polyp-level-fecundity","dir":"Articles","previous_headings":"","what":"ii. Polyp-level fecundity","title":"Bayesian models","text":"Predict total number oocytes per species * size: Extract conditional effects:","code":"brm_fecundity <- brm(eggs ~ log(width)*species,                      cores = 12,                      chains=12,                      iter=4000,                      family = zero_inflated_poisson(),                      prior = c(prior(normal(1, 2), class = Intercept),                                 prior(beta(2, 2), class = zi)                                ),                      data = fecundity) brm_fecundity_cond <- conditional_effects(brm_fecundity, effects = \"width:species\", dpar = \"mu\") brm_fecundity_plots <- brm_fecundity_cond$`width:species` |> as.data.frame() %>%    mutate(species=fct_relevel(species,sp_order)) |>    mutate(growthform=fct_recode(species, \"Tabular\"= \"Acropora cytherea\", \"Tabular\"= \"Acropora hyacinthus\",                                          \"Branching\"= \"Acropora intermedia\", \"Branching\"= \"Acropora robusta\",                                         \"Massive\" = \"Goniastrea pectinata\", \"Massive\" = \"Goniastrea retiformis\",                                         \"Corymbose\" = \"Acropora nasuta\", \"Corymbose\" = \"Acropora millepora\",                                          \"Corymbose\" = \"Acropora spathulata\",                                         \"Digitate\" = \"Acropora cf. digitifera\", \"Digitate\" = \"Acropora humilis\"))  ggplot() + theme_bw() + facet_wrap(~growthform, scales=\"free_y\") + ylab(\"oocytes per polyp\") +   geom_line(data=brm_fecundity_plots, aes(width, estimate__, color=species), show.legend=TRUE) +   geom_ribbon(data=brm_fecundity_plots, aes(width, ymin=lower__, ymax=upper__, fill=species), alpha=0.2, show.legend=TRUE) +   scale_color_manual(values=sp_pal) + scale_fill_manual(values=sp_pal)"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/brms.html","id":"iii--colony-level-fecundity","dir":"Articles","previous_headings":"","what":"iii. Colony-level fecundity","title":"Bayesian models","text":"Predict probability fecundity per species (binary depending colony size: Extract conditional effects:","code":"brm_probability <- brm(reproductive ~ log(width) * species,                        cores = 12,                        chains = 12,                        iter = 4000,                        family = bernoulli(),                        data = fecundity) #| class-source: fold-hide #| message: false #| warning: false #| fig-width: 9.5 #| fig-height: 5  brm_probability_cond <- conditional_effects(brm_probability, effects = \"width:species\", dpar = \"mu\") brm_probability_plots <-  brm_probability_cond$`width:species` |> as.data.frame() %>%    mutate(growthform=fct_recode(species, \"Tabular\"= \"Acropora cytherea\", \"Tabular\"= \"Acropora hyacinthus\",                                          \"Branching\"= \"Acropora intermedia\", \"Branching\"= \"Acropora robusta\",                                         \"Massive\" = \"Goniastrea pectinata\", \"Massive\" = \"Goniastrea retiformis\",                                         \"Corymbose\" = \"Acropora nasuta\", \"Corymbose\" = \"Acropora millepora\", \"Corymbose\" = \"Acropora spathulata\",                                         \"Digitate\" = \"Acropora cf. digitifera\", \"Digitate\" = \"Acropora humilis\"))  ggplot() + theme_bw() + facet_wrap(~growthform, scales=\"free_y\") +   geom_line(data=brm_probability_plots, aes(width, estimate__, color=species), show.legend=TRUE) +   geom_ribbon(data=brm_probability_plots, aes(width, ymin=lower__, ymax=upper__, fill=species), alpha=0.2, show.legend=TRUE) +     scale_color_manual(values=sp_pal) + scale_fill_manual(values=sp_pal) +    ylab(\"Probability of reproductive colonies\") + xlab(\"Colony width\")"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/brms.html","id":"iv--colony-level-polyp-density","dir":"Articles","previous_headings":"","what":"iv. Colony-level polyp density","title":"Bayesian models","text":"Predict probability density polyps per cm^2 per species: Extract conditional effects:","code":"brm_polyp_density <- brm(cm2 ~ species,                          family = gaussian,                          iter = 10000,                          chains = 8,                          cores = 11,                          data=polyp_density_data) # add a hack to get millepora, assume it's between millepora and nasuta millepora <- polyp_density_data |> filter(species==\"Acropora nasuta\" | species==\"Acropora spathulata\") |>                  mutate(species=\"Acropora millepora\") |>                  mutate(spp = \"AM\")  # rejoin polyp_density_data <- polyp_density_data |> rbind(millepora) |>    mutate(growthform=fct_recode(species, \"Tabular\"= \"Acropora cytherea\", \"Tabular\"= \"Acropora hyacinthus\",                                          \"Branching\"= \"Acropora intermedia\", \"Branching\"= \"Acropora robusta\",                                         \"Massive\" = \"Goniastrea pectinata\", \"Massive\" = \"Goniastrea retiformis\",                                         \"Corymbose\" = \"Acropora nasuta\", \"Corymbose\" = \"Acropora millepora\",                                          \"Corymbose\" = \"Acropora spathulata\",                                         \"Digitate\" = \"Acropora cf. digitifera\", \"Digitate\" = \"Acropora humilis\"))  ### data prep above for the brms model     brm_polyp_density_cond <- conditional_effects(brm_polyp_density, effects = \"species\", dpar = \"mu\")  brm_probability_plots <-  brm_polyp_density_cond$species |> as.data.frame() %>%    mutate(growthform=fct_recode(species, \"Tabular\"= \"Acropora cytherea\", \"Tabular\"= \"Acropora hyacinthus\",                                          \"Branching\"= \"Acropora intermedia\", \"Branching\"= \"Acropora robusta\",                                         \"Massive\" = \"Goniastrea pectinata\", \"Massive\" = \"Goniastrea retiformis\",                                         \"Corymbose\" = \"Acropora nasuta\", \"Corymbose\" = \"Acropora millepora\", \"Corymbose\" = \"Acropora spathulata\",                                         \"Digitate\" = \"Acropora cf. digitifera\", \"Digitate\" = \"Acropora humilis\"))  ggplot() + theme_bw() + facet_wrap(~growthform, scales=\"free\") +   geom_col(data=brm_probability_plots, aes(species, estimate__, fill=species),             color=\"black\", alpha=0.5, linewidth=0.5, show.legend=FALSE) +   geom_errorbar(data=brm_probability_plots, aes(species, estimate__, ymin=lower__, ymax=upper__, fill=species),                  width=0.05, color=\"black\", alpha=0.8, linewidth=0.5, show.legend=FALSE) +   theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=0.8)) +   scale_color_manual(values=sp_pal) + scale_fill_manual(values=sp_pal) +    ylab(bquote('Polyps per'*~cm^2*'')) + xlab(\"\")"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/brms.html","id":"v--colony-level-reproductive-area","dir":"Articles","previous_headings":"","what":"v. Colony-level reproductive area","title":"Bayesian models","text":"Predict proportion coral area reproductive (within sterile growth zone borders):","code":"sterile_zone <- tibble(        species = c(\"Acropora hyacinthus\", \"Acropora cytherea\", \"Acropora cf. digitifera\",                    \"Acropora humilis\", \"Acropora nasuta\", \"Acropora spathulata\",                    \"Acropora millepora\",\"Acropora intermedia\",\"Acropora robusta\"),        lower__ = c(0.760, 0.999, 0.773, 0.995, 0.970, 0.885, 0.885, 0.760, 0.760),        median = c(0.771, 1.000, 0.868, 1.000, 0.999, 0.913, 0.913, 0.771, 0.771),        upper__ = c(0.781, 1.000, 0.936, 1.000, 1.000, 0.941, 0.941, 0.781, 0.781)         )  |>    mutate(growthform=fct_recode(species, \"Tabular\"= \"Acropora cytherea\", \"Tabular\"= \"Acropora hyacinthus\",                                          \"Branching\"= \"Acropora intermedia\", \"Branching\"= \"Acropora robusta\",                                         \"Corymbose\" = \"Acropora nasuta\", \"Corymbose\" = \"Acropora millepora\", \"Corymbose\" = \"Acropora spathulata\",                                         \"Digitate\" = \"Acropora cf. digitifera\", \"Digitate\" = \"Acropora humilis\")) |>    bind_rows(data.frame(species = c(\"Goniastrea retiformis\", \"Goniastrea pectinata\"),                                           lower__ = c(1,1),                                           median = c(1,1),                                           upper__ = c(1,1),                                           growthform = c(\"Massive\",\"Massive\")))  ggplot() + theme_bw() + facet_wrap(~growthform, scales=\"free_x\") +   geom_col(data=sterile_zone, aes(species, median*100, fill=species),             color=\"black\", alpha=0.3, linewidth=0.5, show.legend=FALSE) +   geom_errorbar(data=sterile_zone, aes(species, median*100, ymin=lower__*100, ymax=upper__*100),                  width=0.05, color=\"black\", alpha=0.8, linewidth=0.5, show.legend=FALSE) +    theme(axis.text.x = element_text(angle = 45, vjust = 0.9, hjust=0.8)) +   scale_color_manual(values=sp_pal) + scale_fill_manual(values=sp_pal) +    ylab(\"Proportion colony reproductive\") + xlab(\"\")"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/brms.html","id":"simulate-colonies","dir":"Articles","previous_headings":"","what":"2. Simulate colonies","title":"Bayesian models","text":"Combine vars get total output per colony * species (data.table predictions speed):","code":"library(data.table)  # Set number of posterior draws ndraws <- 5000  # Convert coralsize to data.table coralsize <- as.data.table(coralsize)  # Step 1: Max width per species maxwidth_dt <- coralsize[, .(maxwidth = max(width)), by = species]  # Step 2: Build species × width grid base_newdf <- CJ(   species = unique(coralsize$species),   width = seq(2, 200, 4) ) base_newdf <- merge(base_newdf, maxwidth_dt, by = \"species\")[width <= maxwidth][, maxwidth := NULL]  # Step 3: Repeat for draws newdf <- base_newdf[rep(1:.N, each = ndraws)][, draw := rep(1:ndraws, times = .N / ndraws)]  # Step 4: Posterior predictions for each model pp_polyp   <- posterior_predict(brm_polyp_density, newdata = base_newdf, ndraws = ndraws) pp_repro   <- posterior_predict(brm_probability, newdata = base_newdf, ndraws = ndraws) pp_oocytes <- posterior_predict(brm_fecundity, newdata = base_newdf, ndraws = ndraws)  # Step 5: Flatten predictions into long vector newdf[, polypdensity := as.numeric(pp_polyp)] newdf[, reproductive_probability := as.numeric(pp_repro)] newdf[, oocytes := as.numeric(pp_oocytes)]  # Step 6: Sample sterile zone proportions newdf[, sterile_proportion := sample_sterile_zone(species_vec = species, draw = \"random\")]  # Step 7: Calculate reproductive output newdf[, area := pi * (width / 2)^2] newdf[, colony_polyps := polypdensity * area * 10000] newdf[, reproductive_polyps := colony_polyps * sterile_proportion] newdf[, output := reproductive_polyps * oocytes * reproductive_probability]  # Step 8: Summarise posterior output summary_dt <- newdf[, .(   median.output = mean(output),   lower.ci.output = quantile(output, 0.2),   upper.ci.output = quantile(output, 0.8) ), by = .(species, width)]  # Step 9: Add growthform and factor levels summary_dt[, species := factor(species, levels = sp_order)] summary_dt[, growthform := fct_recode(species,                                       \"Tabular\"   = \"Acropora cytherea\",                                       \"Tabular\"   = \"Acropora hyacinthus\",                                       \"Branching\" = \"Acropora intermedia\",                                       \"Branching\" = \"Acropora robusta\",                                       \"Massive\"   = \"Goniastrea pectinata\",                                       \"Massive\"   = \"Goniastrea retiformis\",                                       \"Corymbose\" = \"Acropora nasuta\",                                       \"Corymbose\" = \"Acropora millepora\",                                       \"Corymbose\" = \"Acropora spathulata\",                                       \"Digitate\"  = \"Acropora cf. digitifera\",                                       \"Digitate\"  = \"Acropora humilis\" )]    ggplot() + theme_bw() +    geom_line(data=summary_dt, aes(width, median.output, color=species), linewidth=1.2) +    scale_y_continuous(labels = scales::comma) +   scale_color_manual(values=sp_pal) + scale_fill_manual(values=sp_pal) ggplot() +    theme_bw() +    facet_wrap(~growthform, scales = \"free_y\") +   geom_ribbon(data = summary_dt, aes(width, ymin = lower.ci.output, ymax = upper.ci.output, fill = species), alpha = 0.4) +    geom_line(data = summary_dt, aes(width, median.output, color = species)) +    scale_y_continuous(labels = scales::comma) +   scale_color_manual(values = sp_pal) +    scale_fill_manual(values = sp_pal) +   theme(legend.position = \"bottom\")"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/coralbleaching.html","id":"no-bleaching-scenario","dir":"Articles","previous_headings":"","what":"2024 “no bleaching” scenario","title":"Coral Bleaching","text":"","code":"library(tidyverse) library(sf) library(reefspawn)  seedval = 321   coral_size_2024 <- simulate_coralsize(coralsize |> filter(year==2011),                                        distribution = \"rlnorm\",                                        ndraws = 2000,                                       seed = seedval)  sf_plot <- setplot(20,10) # default EPSG:3857 coralsizepredictions <- posterior_coral_predict(brm = brm_sizedistribution,                                                 newdata = coral_size_2024,                                                  seed = seedval)  communities <- simulate_community(setplot = sf_plot,                                   coralcover = 40,                                   size = coral_size_2024,                                   seed = seedval)  populations <- simulate_populations(setplot = sf_plot,                                     size = coral_size_2024,                                     community = communities,                                     return=\"sf\",                                     seed = seedval)   reproductive_populations <- simulate_spawning(populations = populations,                                         setplot = sf_plot,                                         seed = 123)  map_populations(setplot = sf_plot,                 populations = reproductive_populations, # or reproductive output, same sf population                 interactive = TRUE)"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/coralbleaching.html","id":"bleaching-scenario","dir":"Articles","previous_headings":"","what":"2024 “bleaching” scenario","title":"Coral Bleaching","text":"","code":"reproductive_populations_postbleaching <- simulate_bleaching(populations = reproductive_populations)  map_populations(setplot = sf_plot,                  populations = reproductive_populations_postbleaching,                  interactive = TRUE) library(DT)  # colony level info: colony_output <- reproductive_populations_postbleaching |>    as.data.frame() |>    group_by(status, species) |>    summarise(n = n(), .groups = \"drop\") |>    pivot_wider(names_from = status, values_from = n, values_fill = 0) |>    mutate(     prebleaching_n = bleached + unbleached,     postbleaching_n = unbleached,     percent_mortality = round((bleached / prebleaching_n) * 100, 1)   ) |> select(-bleached, -unbleached)  reactable::reactable(   head(colony_output, 20),   defaultPageSize = 20,   pagination = FALSE,   searchable = FALSE,   highlight = TRUE,   bordered = TRUE,   striped = TRUE ) population_output <- reproductive_populations_postbleaching |>    as.data.frame() |>    group_by(status, species) |>    summarise(     mean_output = mean(output),     total_output = sum(output),     .groups = \"drop\"   ) |>    pivot_wider(     names_from = status,     values_from = c(mean_output, total_output),     names_glue = \"{.value}_{status}\"   ) |>    mutate(     mean_output_change = round(100 * (mean_output_unbleached - mean_output_bleached) / mean_output_unbleached, 1),     total_output_change = round(100 * (total_output_unbleached - total_output_bleached) / total_output_unbleached, 1),     mean_output_postbleaching = scales::comma(round(mean_output_unbleached, 1)),     mean_output_prebleaching = scales::comma(round(mean_output_bleached, 1)),     total_output_postbleaching = scales::comma(total_output_bleached),     total_output_prebleaching = scales::comma(total_output_unbleached)   ) |>    select(species, mean_output_prebleaching, mean_output_postbleaching, mean_output_change,           total_output_prebleaching, total_output_postbleaching, total_output_change)   reactable::reactable(   head(population_output, 20),   defaultPageSize = 20,   pagination = FALSE,   searchable = FALSE,   highlight = TRUE,   bordered = TRUE,   striped = TRUE )"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/coralbleaching.html","id":"mortality-estimates","dir":"Articles","previous_headings":"","what":"Mortality estimates","title":"Coral Bleaching","text":"","code":"library(DT)  # colony level info: colony_output <- reproductive_populations_postbleaching |>    as.data.frame() |>    group_by(status, species) |>    summarise(n = n(), .groups = \"drop\") |>    pivot_wider(names_from = status, values_from = n, values_fill = 0) |>    mutate(     prebleaching_n = bleached + unbleached,     postbleaching_n = unbleached,     percent_mortality = round((bleached / prebleaching_n) * 100, 1)   ) |> select(-bleached, -unbleached)  reactable::reactable(   head(colony_output, 20),   defaultPageSize = 20,   pagination = FALSE,   searchable = FALSE,   highlight = TRUE,   bordered = TRUE,   striped = TRUE )"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/coralbleaching.html","id":"reproductive-output-estimates","dir":"Articles","previous_headings":"","what":"Reproductive output estimates","title":"Coral Bleaching","text":"","code":"population_output <- reproductive_populations_postbleaching |>    as.data.frame() |>    group_by(status, species) |>    summarise(     mean_output = mean(output),     total_output = sum(output),     .groups = \"drop\"   ) |>    pivot_wider(     names_from = status,     values_from = c(mean_output, total_output),     names_glue = \"{.value}_{status}\"   ) |>    mutate(     mean_output_change = round(100 * (mean_output_unbleached - mean_output_bleached) / mean_output_unbleached, 1),     total_output_change = round(100 * (total_output_unbleached - total_output_bleached) / total_output_unbleached, 1),     mean_output_postbleaching = scales::comma(round(mean_output_unbleached, 1)),     mean_output_prebleaching = scales::comma(round(mean_output_bleached, 1)),     total_output_postbleaching = scales::comma(total_output_bleached),     total_output_prebleaching = scales::comma(total_output_unbleached)   ) |>    select(species, mean_output_prebleaching, mean_output_postbleaching, mean_output_change,           total_output_prebleaching, total_output_postbleaching, total_output_change)   reactable::reactable(   head(population_output, 20),   defaultPageSize = 20,   pagination = FALSE,   searchable = FALSE,   highlight = TRUE,   bordered = TRUE,   striped = TRUE )"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/experimental.html","id":"bayesian-model-outputs","dir":"Articles","previous_headings":"","what":"bayesian model outputs","title":"Experimental results","text":"strong evidence treatment effect hyacinthus. Estimate –0.38 [–130.57, +128.79M] strong evidence difference area species. Estimate –600.5 [–839.39, +359.22]  strong evidence treatment effect hyacinthus. Estimate –5.5M [–43.8, +33.3] Strong evidence reproductive output lower unimpacted spathulata Estimate –57.9M [–96.7M, –18.9M]  strong evidence treatment effect spathulata. Estimate 456.2 [–483.5, +1409.8] strong evidence treatment effect hyacinthus. Estimate –456.21 [–1409.84, 430.191]  evidence unimpacted reefs lower settler counts impacted reefs. effect size large (–87), uncertain — CI includes small positive values Estimate -87.5 [–176.6, +4.7]  strong evidence treatment effect Estimate 0.52 [–1.42, +0.43]","code":"#| class-source: fold-hide #| message: false #| warning: false #| fig-width: 9.5 #| fig-height: 5  library(tidyverse) library(janitor) library(readxl) library(brms) library(patchwork) library(reefspawn)  egg_diameter_output <- readxl::read_excel(\"/Users/rof011/reefspawn/code/SurvExpData.xlsx\", sheet = \"ReprodOutput\") |>   janitor::clean_names() |>   dplyr::rename(     area = colony_size_cm2,     egg_cover = egg_percent_cover_jar,     egg_depth = egg_layer_tickness_mm,     egg_diameter = mean_egg_diameter_um   ) |>   dplyr::mutate(     egg_diameter = as.numeric(egg_diameter),     treatment = dplyr::case_when(       stringr::str_detect(treatment, \"SURV\") ~ \"impacted\",       stringr::str_detect(treatment, \"NORM\") ~ \"unimpacted\",       TRUE ~ NA_character_     )   ) |>   dplyr::select(treatment, species, egg_diameter) |>   tidyr::drop_na() |>   dplyr::mutate(var = paste0(species, \"_\", treatment))  # Fit model including species # fm_egg_size <- brms::brm( #   egg_diameter ~ treatment * species, #   data = egg_diameter_output, #   cores = 10, #   chains = 4, #   iter = 6000 # ) #  # saveRDS(fm_egg_size, \"/Users/rof011/reefspawn/code/fm_egg_size.rds\")  fm_egg_size <- readRDS(\"/Users/rof011/reefspawn/code/fm_egg_size.rds\")          # Fitted posterior summaries fitted_vals <- fitted(fm_egg_size, scale = \"response\") egg_diameter_output <- egg_diameter_output |>   mutate(     predicted = fitted_vals[, \"Estimate\"],     lower = fitted_vals[, \"Q2.5\"],     upper = fitted_vals[, \"Q97.5\"]   )  # Summarise for model overlay egg_diameter_summary <- egg_diameter_output |>   group_by(species, treatment) |>   summarise(     predicted = unique(predicted),     lower = unique(lower),     upper = unique(upper),     .groups = \"drop\"   )  # Plot a <- ggplot() +   theme_bw() +   facet_wrap(~ species) +   geom_violin(     data = egg_diameter_output,     aes(x = treatment, y = egg_diameter, fill = treatment),     color = \"grey50\", scale = \"width\", alpha = 0.6, show.legend = FALSE   ) +   geom_jitter(     data = egg_diameter_output,     aes(x = treatment, y = egg_diameter, fill = treatment),     width = 0.05, alpha = 0.5, show.legend = FALSE   ) +   geom_boxplot(     data = egg_diameter_summary,     aes(x = treatment, fill = treatment,         lower = lower, upper = upper,         middle = predicted, ymin = lower, ymax = upper),     stat = \"identity\", width = 0.2, alpha = 0.4, show.legend = FALSE   ) +   labs(y = \"Egg size (µm)\", title = \"Egg size by Treatment\") +   scale_fill_manual(values = c(\"navajowhite2\", \"paleturquoise\")) +   scale_y_continuous(limits = c(0, 1000))  a colony_area_output <- readxl::read_excel(\"/Users/rof011/reefspawn/code/SurvExpData.xlsx\", sheet = \"ReprodOutput\") |>   janitor::clean_names() |>   dplyr::rename(     area = colony_size_cm2,     egg_cover = egg_percent_cover_jar,     egg_depth = egg_layer_tickness_mm,     egg_diameter = mean_egg_diameter_um   )|>   dplyr::select(treatment, species, area) |>   tidyr::drop_na() |>   dplyr::mutate(var = paste0(species, \"_\", treatment))  # check colony area differences  # fm_area <- brms::brm( #   area ~  species, #   data = colony_area_output, #   cores = 10, #   chains = 4, #   iter = 6000 # ) #  # saveRDS(fm_area, \"/Users/rof011/reefspawn/code/fm_area.rds\")  fm_area <- readRDS(\"/Users/rof011/reefspawn/code/fm_area.rds\") hypothesis(fm_egg_size, \"treatmentunimpacted = 0\") Hypothesis Tests for class b:                 Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio 1 (treatmentunimpac... = 0    -2.23     65.03  -131.47   125.31         NA   Post.Prob Star 1        NA --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities. hypothesis(fm_area, \"speciesspathulatha = 0\") Hypothesis Tests for class b:                 Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio 1 (speciesspathulatha) = 0  -600.54    121.09  -839.39  -359.22         NA   Post.Prob Star 1        NA    * --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities. hypothesis(fm_egg_size, \"speciesspathulatha = 0\") Hypothesis Tests for class b:                 Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio 1 (speciesspathulatha) = 0    -0.16     61.19  -119.61   121.28         NA   Post.Prob Star 1        NA --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities. #| class-source: fold-hide #| message: false #| warning: false #| fig-width: 9.5 #| fig-height: 5  reproductive_output <- readxl::read_excel(\"/Users/rof011/reefspawn/code/SurvExpData.xlsx\", sheet = \"ReprodOutput\") |>   janitor::clean_names() |>   dplyr::rename(area = colony_size_cm2) |>   dplyr::mutate(     egg_cover = as.numeric(egg_percent_cover_jar),     egg_depth = as.numeric(egg_layer_tickness_mm),     egg_diameter = as.numeric(mean_egg_diameter_um),     treatment = dplyr::case_when(       stringr::str_detect(treatment, \"SURV\") ~ \"impacted\",       stringr::str_detect(treatment, \"NORM\") ~ \"unimpacted\",       TRUE ~ NA_character_     )   ) |>   dplyr::select(treatment, species, area, egg_diameter, egg_cover, egg_depth) |>   dplyr::rowwise() |>   dplyr::mutate(output = calculate_egg_densities(egg_diameter,egg_cover, egg_depth, method = \"3d_packing\"),                 output2 = calculate_egg_densities(egg_diameter,egg_cover, egg_depth, method = \"layered\")     ) |>   dplyr::ungroup() |>   dplyr::mutate(var = paste0(species, \"_\", treatment)) |>   tidyr::drop_na() |>   mutate(output = output / area,          output2 = output2 / area)  # # Fit model with species interaction # fm_reproductive_output <- brm( #   output ~ treatment * species, #   data = reproductive_output, #   cores = 10, #   chains = 4, #   iter = 6000 # ) #  # saveRDS(fm_reproductive_output, \"/Users/rof011/reefspawn/code/fm_reproductive_output.rds\")  fm_reproductive_output <- readRDS(\"/Users/rof011/reefspawn/code/fm_reproductive_output.rds\")          # Extract fitted values fitted_vals <- fitted(fm_reproductive_output, scale = \"response\")  reproductive_output <- reproductive_output |>   mutate(     predicted = fitted_vals[, \"Estimate\"],     lower = fitted_vals[, \"Q2.5\"],     upper = fitted_vals[, \"Q97.5\"]   )  # Summarise predictions per treatment × species for plotting box layer  reproductive_summary <- reproductive_output |>   group_by(species, treatment) |>   summarise(     predicted = unique(predicted),     lower = unique(lower),     upper = unique(upper),     .groups = \"drop\"   )  # Plot b <- ggplot() +   theme_bw() +   facet_wrap(~ species) +   geom_violin(     data = reproductive_output,     aes(x = treatment, y = output, fill = treatment),     color = \"grey50\", scale = \"width\", alpha = 0.6, show.legend = FALSE   ) +   geom_jitter(     data = reproductive_output,     aes(x = treatment, y = output, fill = treatment),     width = 0.05, alpha = 0.5, show.legend = FALSE   ) +   geom_boxplot(     data = reproductive_summary,     aes(x = treatment, fill = treatment,         lower = lower, upper = upper,         middle = predicted, ymin = lower, ymax = upper),     stat = \"identity\", width = 0.2, alpha = 0.7, show.legend = FALSE   ) +   labs(y = \"Reproductive output (n per cm2)\", title = \"Reproductive output by Treatment\") +   scale_fill_manual(values = c(\"navajowhite2\", \"paleturquoise\"))  b hypothesis(fm_reproductive_output, \"treatmentunimpacted = 0\") Hypothesis Tests for class b:                 Hypothesis Estimate Est.Error  CI.Lower CI.Upper Evid.Ratio 1 (treatmentunimpac... = 0 -5138974  19355732 -42924849 32449033         NA   Post.Prob Star 1        NA --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities. hypothesis(fm_reproductive_output, \"treatmentunimpacted + treatmentunimpacted:speciesspathulatha = 0\") Hypothesis Tests for class b:                 Hypothesis  Estimate Est.Error  CI.Lower  CI.Upper Evid.Ratio 1 (treatmentunimpac... = 0 -58137442  19952480 -97621677 -18695671         NA   Post.Prob Star 1        NA    * --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities. #| class-source: fold-hide #| message: false #| warning: false #| fig-width: 9.5 #| fig-height: 5   string_treatment <- c(rep(\"S1\",3), rep(\"N2\", 3), rep(\"S2\", 3), rep(\"N1\", 3))   onboard_cultures <- readxl::read_excel(\"/Users/rof011/reefspawn/code/SurvExpData.xlsx\", sheet = \"OnboardCulture\") |>   janitor::clean_names() |>   # clean up time   dplyr::mutate(time = as.POSIXct(samping_date, format = \"%d/%m/%Y\", tz = \"UTC\")) |>   dplyr::mutate(time = as.numeric(difftime(time, min(time), units = \"days\"))) |>   # clean up ID   #dplyr::filter(!is.na(treatment_id)) |>   dplyr::mutate(treatment = stringr::str_remove(treatment_id, \"^Tank_\")) |>   dplyr::mutate(sample_prefix = ifelse(is.na(sample_id), NA, substr(sample_id, 1, 2))) |>   dplyr::mutate(treatment = ifelse(is.na(treatment_id), sample_prefix, treatment_id)) %>%  # replace missing treatment_id with sample_prefix, check seperately   dplyr::filter(treatment %in% c(\"N1\", \"N2\", \"S1\", \"S2\")) %>%   mutate(rep = rep(c(\"a\", \"b\", \"c\"), (nrow(.)/3))) |>   select(treatment, time, deformed, normal, total_larvae) |>   group_by(treatment, time) |>   summarise(deformed = mean(deformed), normal = mean(normal), total_larvae = mean(total_larvae)) |>   dplyr::mutate(species = dplyr::case_when(     stringr::str_detect(treatment, \"1$\") ~ \"hyacinthus\",     stringr::str_detect(treatment, \"2$\") ~ \"spathulata\",     TRUE ~ NA_character_   )) |>   dplyr::mutate(var = paste0(species, \"_\", treatment)) |>   tidyr::separate(var, into = c(\"species\", \"treatment\"), sep = \"_\") |>   dplyr::mutate(condition = dplyr::case_when(     stringr::str_detect(treatment, \"^N\") ~ \"unimpacted\",     stringr::str_detect(treatment, \"^S\") ~ \"impacted\",     TRUE ~ NA_character_   )) |>   mutate(total_larvae = (total_larvae/16) * 1000) |>    mutate(treatment = condition)  # quadratic_counts <- brm( #   total_larvae ~ time + I(time^2) * treatment * species, #   data = onboard_cultures, #   family = gaussian(), #   chains = 4, cores = 4 # )  # saveRDS(quadratic_counts, \"/Users/rof011/reefspawn/code/quadratic_counts.rds\")  quadratic_counts <- readRDS(\"/Users/rof011/reefspawn/code/quadratic_counts.rds\")   # Expand prediction grid with full interaction structure newdata <- tidyr::expand_grid(   time = seq(min(onboard_cultures$time), max(onboard_cultures$time), length.out = 100),   treatment = unique(onboard_cultures$treatment),   species = unique(onboard_cultures$species) )  # Get predicted values with uncertainty quad_fitted <- fitted(   quadratic_counts,   newdata = newdata,   scale = \"response\",   allow_new_levels = TRUE ) |> as_tibble()  # Combine predictions newdata_quad <- bind_cols(newdata, quad_fitted)  # Add condition back (if needed for fill/color) newdata_quad <- newdata_quad |>   left_join(onboard_cultures |> distinct(treatment, species, condition), by = c(\"treatment\", \"species\"))  # Plot plot_c <- ggplot() +   theme_bw() +   facet_wrap(~ species) +   geom_ribbon(data = newdata_quad, aes(x = time, ymin = Q2.5, ymax = Q97.5, fill = condition),               alpha = 0.5, show.legend = FALSE) +   geom_line(data = newdata_quad, aes(x = time, y = Estimate, color = condition),             linewidth = 1.2, show.legend = FALSE) +   geom_line(data = onboard_cultures, aes(x = time, y = total_larvae, color = condition),             linetype = \"dashed\", show.legend = FALSE) +   geom_point(data = onboard_cultures, aes(x = time, y = total_larvae, fill = condition),              shape = 21, color = \"black\", size = 2, alpha = 0.9, show.legend = FALSE) +   labs(     title = \"Quadratic fit of larval counts over time\",     y = \"n larvae / litre\",     x = \"Time (days)\"   ) +   scale_fill_manual(values = c(\"navajowhite\", \"paleturquoise\")) +   scale_color_manual(values = c(\"navajowhite3\", \"paleturquoise3\")) +   coord_cartesian(ylim = c(0, 2500))   plot_c hypothesis(quadratic_counts, \"treatmentunimpacted + ItimeE2:treatmentunimpacted = 0\") Hypothesis Tests for class b:                 Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio 1 (treatmentunimpac... = 0   215.11    457.61  -717.78   1165.8         NA   Post.Prob Star 1        NA --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities. hypothesis(quadratic_counts,   \"treatmentunimpacted +    ItimeE2:treatmentunimpacted +    treatmentunimpacted:speciesspathulata +    ItimeE2:treatmentunimpacted:speciesspathulata = 0\") Hypothesis Tests for class b:                 Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio 1 (treatmentunimpac... = 0  -483.54    456.21 -1409.84   430.19         NA   Post.Prob Star 1        NA --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities. #| class-source: fold-hide #| message: false #| warning: false #| fig-width: 9.5 #| fig-height: 5    tiles <- readxl::read_excel(\"/Users/rof011/reefspawn/code/SurvExpData.xlsx\", sheet = \"SetTilesSurvREEF_cleaned\") |>   janitor::clean_names() |>   mutate(days = date_scored - date_tile_deployment) |>   group_by(plot_id, days, tile_face, treatment, tile_number) |>   summarise(total_count = sum(settler_count)) |>   mutate(days = as.numeric(days)) |>   mutate(days = ifelse(days <100, \"5 days\", \"110 days\")) |>   mutate(days = as.factor(days)) |>   filter(treatment %in% c(\"Normal\", \"Survivor\")) |>   dplyr::mutate(     treatment = dplyr::case_when(       stringr::str_detect(treatment, \"Survivor\") ~ \"impacted\",       stringr::str_detect(treatment, \"Normal\") ~ \"unimpacted\",       TRUE ~ NA_character_     )   )   tiles_grouped <- tiles |>   group_by(days, treatment, plot_id, tile_number) |>   summarise(total_count = sum(total_count))  tiles_grouped_mean <- tiles_grouped |>   group_by(days, treatment) |>   summarise(total_count = mean(total_count))  ### first timepoint  tiles_counts_a <- brm(   total_count ~ treatment + (1|plot_id),   data = tiles_grouped |> filter(days == \"5 days\"),   family = gaussian(),   chains = 4, cores = 4 )  # saveRDS(tiles_counts_a, \"/Users/rof011/reefspawn/code/tiles_counts_a.rds\")  tiles_counts_a <- readRDS(\"/Users/rof011/reefspawn/code/tiles_counts_a.rds\")  # Create prediction grid tiles_counts_a_newdata <- expand.grid(   treatment = unique(tiles_grouped$treatment),   plot_id = NA  # marginalize over random effect )  # Get fitted values on response scale with uncertainty tiles_counts_a_fitted_vals <- fitted(tiles_counts_a, newdata = tiles_counts_a_newdata, scale = \"response\", allow_new_levels = TRUE) |> as_tibble() tiles_counts_a_newdata <- bind_cols(tiles_counts_a_newdata, tiles_counts_a_fitted_vals)  # # ggplot() + #   theme_bw() + #   geom_point(data = tiles_grouped |> filter(days == \"5 days\"), aes(x = treatment, y = total_count, fill = treatment), #              shape = 21, color = \"black\", alpha = 0.5, size = 2, position = position_jitter(width = 0.1)) + #   geom_pointrange(data = tiles_counts_a_newdata, #                   aes(x = treatment, y = Estimate, ymin = Q2.5, ymax = Q97.5, fill = treatment), #                   shape = 21, color = \"black\", size = 1.2) + #   labs(title = \"Predicted settler counts by treatment (ZIP model)\", #        y = \"Predicted count (mean ± 95% CI)\", x = \"Treatment\") + #   scale_fill_manual(values = c(\"paleturquoise\", \"navajowhite\"))  tileplot_a <- ggplot() + theme_bw() + facet_wrap(~days) +   geom_violin(data = tiles_grouped |> filter(days == \"5 days\"), aes(treatment, total_count, fill=treatment), linewidth=0.25, alpha=0.2, show.legend = FALSE) +   geom_jitter(data = tiles_grouped |> filter(days == \"5 days\"), aes(treatment, total_count), width=0.1, size=0.4, alpha=0.2, show.legend = FALSE) +   geom_pointrange(data = tiles_counts_a_newdata,                   aes(x = treatment, y = Estimate, ymin = Q2.5, ymax = Q97.5, fill = treatment),                   shape = 21, linewidth=0.5, color = \"black\", size = 0.6, show.legend = FALSE) +   scale_fill_manual(values = c(\"paleturquoise\", \"navajowhite\")) + ylab(\"Larvae per tile\")  tileplot_a hypothesis(tiles_counts_a, \"treatmentunimpacted = 0\") Hypothesis Tests for class b:                 Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio 1 (treatmentunimpac... = 0   -87.49     47.36  -176.56     4.67         NA   Post.Prob Star 1        NA --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities. #| class-source: fold-hide #| message: false #| warning: false #| fig-width: 9.5 #| fig-height: 5   # tiles_counts_b <- brm( #   total_count ~ treatment + (1|plot_id), #   data = tiles_grouped |> filter(days == \"110 days\"), #   family = zero_inflated_poisson(), #   chains = 4, cores = 4, adapt_delta = 0.95: # ) # # saveRDS(tiles_counts_b, \"/Users/rof011/reefspawn/code/tiles_counts_b.rds\")  tiles_counts_b <- readRDS(\"/Users/rof011/reefspawn/code/tiles_counts_b.rds\")   # Create prediction grid tiles_counts_b_newdata <- expand.grid(   treatment = unique(tiles_grouped$treatment),   plot_id = NA  # marginalize over random effect )  # Get fitted values on response scale with uncertainty tiles_counts_b_fitted_vals <- fitted(tiles_counts_b, newdata = tiles_counts_b_newdata, scale = \"response\", allow_new_levels = TRUE) |> as_tibble() tiles_counts_b_newdata <- bind_cols(tiles_counts_b_newdata, tiles_counts_b_fitted_vals)  # # tileplot_b <- ggplot() + #   theme_bw() + #   geom_point(data = tiles_grouped |> filter(days == \"5 days\"), aes(x = treatment, y = total_count, fill = treatment), #              shape = 21, color = \"black\", alpha = 0.5, size = 2, position = position_jitter(width = 0.1)) + #   geom_pointrange(data = tiles_counts_b_newdata, #                   aes(x = treatment, y = Estimate, ymin = Q2.5, ymax = Q97.5, fill = treatment), #                   shape = 21, color = \"black\", size = 1.2) + #   labs(title = \"Predicted settler counts by treatment (ZIP model)\", #        y = \"Predicted count (mean ± 95% CI)\", x = \"Treatment\") + #   scale_fill_manual(values = c(\"paleturquoise\", \"navajowhite\"))  tileplot_b <- ggplot() + theme_bw() + facet_wrap(~days) +   geom_violin(data = tiles_grouped |> filter(days == \"110 days\"), aes(treatment, total_count, fill=treatment), linewidth=0.25, alpha=0.2, show.legend = FALSE) +   geom_jitter(data = tiles_grouped |> filter(days == \"110 days\"), aes(treatment, total_count), width=0.1, size=0.4, alpha=0.2, show.legend = FALSE) +   geom_pointrange(data = tiles_counts_b_newdata,                   aes(x = treatment, y = Estimate, ymin = Q2.5, ymax = Q97.5, fill = treatment),                   shape = 21, linewidth=0.5, stroke = 0.5, color = \"black\", size = 0.6, show.legend = FALSE) +   scale_fill_manual(values = c(\"paleturquoise\", \"navajowhite\")) + ylab(\"Larvae per tile\")  tileplot_b hypothesis(tiles_counts_b, \"treatmentunimpacted = 0\") Hypothesis Tests for class b:                 Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio 1 (treatmentunimpac... = 0    -0.52      0.47    -1.42     0.43         NA   Post.Prob Star 1        NA --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities."},{"path":"https://marine-ecologist.github.io/reefspawn/articles/experimental.html","id":"oocyte-diameter","dir":"Articles","previous_headings":"","what":"Oocyte diameter","title":"Experimental results","text":"strong evidence treatment effect hyacinthus. Estimate –0.38 [–130.57, +128.79M] strong evidence difference area species. Estimate –600.5 [–839.39, +359.22]","code":"#| class-source: fold-hide #| message: false #| warning: false #| fig-width: 9.5 #| fig-height: 5  library(tidyverse) library(janitor) library(readxl) library(brms) library(patchwork) library(reefspawn)  egg_diameter_output <- readxl::read_excel(\"/Users/rof011/reefspawn/code/SurvExpData.xlsx\", sheet = \"ReprodOutput\") |>   janitor::clean_names() |>   dplyr::rename(     area = colony_size_cm2,     egg_cover = egg_percent_cover_jar,     egg_depth = egg_layer_tickness_mm,     egg_diameter = mean_egg_diameter_um   ) |>   dplyr::mutate(     egg_diameter = as.numeric(egg_diameter),     treatment = dplyr::case_when(       stringr::str_detect(treatment, \"SURV\") ~ \"impacted\",       stringr::str_detect(treatment, \"NORM\") ~ \"unimpacted\",       TRUE ~ NA_character_     )   ) |>   dplyr::select(treatment, species, egg_diameter) |>   tidyr::drop_na() |>   dplyr::mutate(var = paste0(species, \"_\", treatment))  # Fit model including species # fm_egg_size <- brms::brm( #   egg_diameter ~ treatment * species, #   data = egg_diameter_output, #   cores = 10, #   chains = 4, #   iter = 6000 # ) #  # saveRDS(fm_egg_size, \"/Users/rof011/reefspawn/code/fm_egg_size.rds\")  fm_egg_size <- readRDS(\"/Users/rof011/reefspawn/code/fm_egg_size.rds\")          # Fitted posterior summaries fitted_vals <- fitted(fm_egg_size, scale = \"response\") egg_diameter_output <- egg_diameter_output |>   mutate(     predicted = fitted_vals[, \"Estimate\"],     lower = fitted_vals[, \"Q2.5\"],     upper = fitted_vals[, \"Q97.5\"]   )  # Summarise for model overlay egg_diameter_summary <- egg_diameter_output |>   group_by(species, treatment) |>   summarise(     predicted = unique(predicted),     lower = unique(lower),     upper = unique(upper),     .groups = \"drop\"   )  # Plot a <- ggplot() +   theme_bw() +   facet_wrap(~ species) +   geom_violin(     data = egg_diameter_output,     aes(x = treatment, y = egg_diameter, fill = treatment),     color = \"grey50\", scale = \"width\", alpha = 0.6, show.legend = FALSE   ) +   geom_jitter(     data = egg_diameter_output,     aes(x = treatment, y = egg_diameter, fill = treatment),     width = 0.05, alpha = 0.5, show.legend = FALSE   ) +   geom_boxplot(     data = egg_diameter_summary,     aes(x = treatment, fill = treatment,         lower = lower, upper = upper,         middle = predicted, ymin = lower, ymax = upper),     stat = \"identity\", width = 0.2, alpha = 0.4, show.legend = FALSE   ) +   labs(y = \"Egg size (µm)\", title = \"Egg size by Treatment\") +   scale_fill_manual(values = c(\"navajowhite2\", \"paleturquoise\")) +   scale_y_continuous(limits = c(0, 1000))  a colony_area_output <- readxl::read_excel(\"/Users/rof011/reefspawn/code/SurvExpData.xlsx\", sheet = \"ReprodOutput\") |>   janitor::clean_names() |>   dplyr::rename(     area = colony_size_cm2,     egg_cover = egg_percent_cover_jar,     egg_depth = egg_layer_tickness_mm,     egg_diameter = mean_egg_diameter_um   )|>   dplyr::select(treatment, species, area) |>   tidyr::drop_na() |>   dplyr::mutate(var = paste0(species, \"_\", treatment))  # check colony area differences  # fm_area <- brms::brm( #   area ~  species, #   data = colony_area_output, #   cores = 10, #   chains = 4, #   iter = 6000 # ) #  # saveRDS(fm_area, \"/Users/rof011/reefspawn/code/fm_area.rds\")  fm_area <- readRDS(\"/Users/rof011/reefspawn/code/fm_area.rds\") hypothesis(fm_egg_size, \"treatmentunimpacted = 0\") Hypothesis Tests for class b:                 Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio 1 (treatmentunimpac... = 0    -2.23     65.03  -131.47   125.31         NA   Post.Prob Star 1        NA --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities. hypothesis(fm_area, \"speciesspathulatha = 0\") Hypothesis Tests for class b:                 Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio 1 (speciesspathulatha) = 0  -600.54    121.09  -839.39  -359.22         NA   Post.Prob Star 1        NA    * --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities. hypothesis(fm_egg_size, \"speciesspathulatha = 0\") Hypothesis Tests for class b:                 Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio 1 (speciesspathulatha) = 0    -0.16     61.19  -119.61   121.28         NA   Post.Prob Star 1        NA --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities."},{"path":"https://marine-ecologist.github.io/reefspawn/articles/experimental.html","id":"oocyte-biomass","dir":"Articles","previous_headings":"","what":"Oocyte biomass","title":"Experimental results","text":"strong evidence treatment effect hyacinthus. Estimate –5.5M [–43.8, +33.3] Strong evidence reproductive output lower unimpacted spathulata Estimate –57.9M [–96.7M, –18.9M]","code":"#| class-source: fold-hide #| message: false #| warning: false #| fig-width: 9.5 #| fig-height: 5  reproductive_output <- readxl::read_excel(\"/Users/rof011/reefspawn/code/SurvExpData.xlsx\", sheet = \"ReprodOutput\") |>   janitor::clean_names() |>   dplyr::rename(area = colony_size_cm2) |>   dplyr::mutate(     egg_cover = as.numeric(egg_percent_cover_jar),     egg_depth = as.numeric(egg_layer_tickness_mm),     egg_diameter = as.numeric(mean_egg_diameter_um),     treatment = dplyr::case_when(       stringr::str_detect(treatment, \"SURV\") ~ \"impacted\",       stringr::str_detect(treatment, \"NORM\") ~ \"unimpacted\",       TRUE ~ NA_character_     )   ) |>   dplyr::select(treatment, species, area, egg_diameter, egg_cover, egg_depth) |>   dplyr::rowwise() |>   dplyr::mutate(output = calculate_egg_densities(egg_diameter,egg_cover, egg_depth, method = \"3d_packing\"),                 output2 = calculate_egg_densities(egg_diameter,egg_cover, egg_depth, method = \"layered\")     ) |>   dplyr::ungroup() |>   dplyr::mutate(var = paste0(species, \"_\", treatment)) |>   tidyr::drop_na() |>   mutate(output = output / area,          output2 = output2 / area)  # # Fit model with species interaction # fm_reproductive_output <- brm( #   output ~ treatment * species, #   data = reproductive_output, #   cores = 10, #   chains = 4, #   iter = 6000 # ) #  # saveRDS(fm_reproductive_output, \"/Users/rof011/reefspawn/code/fm_reproductive_output.rds\")  fm_reproductive_output <- readRDS(\"/Users/rof011/reefspawn/code/fm_reproductive_output.rds\")          # Extract fitted values fitted_vals <- fitted(fm_reproductive_output, scale = \"response\")  reproductive_output <- reproductive_output |>   mutate(     predicted = fitted_vals[, \"Estimate\"],     lower = fitted_vals[, \"Q2.5\"],     upper = fitted_vals[, \"Q97.5\"]   )  # Summarise predictions per treatment × species for plotting box layer  reproductive_summary <- reproductive_output |>   group_by(species, treatment) |>   summarise(     predicted = unique(predicted),     lower = unique(lower),     upper = unique(upper),     .groups = \"drop\"   )  # Plot b <- ggplot() +   theme_bw() +   facet_wrap(~ species) +   geom_violin(     data = reproductive_output,     aes(x = treatment, y = output, fill = treatment),     color = \"grey50\", scale = \"width\", alpha = 0.6, show.legend = FALSE   ) +   geom_jitter(     data = reproductive_output,     aes(x = treatment, y = output, fill = treatment),     width = 0.05, alpha = 0.5, show.legend = FALSE   ) +   geom_boxplot(     data = reproductive_summary,     aes(x = treatment, fill = treatment,         lower = lower, upper = upper,         middle = predicted, ymin = lower, ymax = upper),     stat = \"identity\", width = 0.2, alpha = 0.7, show.legend = FALSE   ) +   labs(y = \"Reproductive output (n per cm2)\", title = \"Reproductive output by Treatment\") +   scale_fill_manual(values = c(\"navajowhite2\", \"paleturquoise\"))  b hypothesis(fm_reproductive_output, \"treatmentunimpacted = 0\") Hypothesis Tests for class b:                 Hypothesis Estimate Est.Error  CI.Lower CI.Upper Evid.Ratio 1 (treatmentunimpac... = 0 -5138974  19355732 -42924849 32449033         NA   Post.Prob Star 1        NA --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities. hypothesis(fm_reproductive_output, \"treatmentunimpacted + treatmentunimpacted:speciesspathulatha = 0\") Hypothesis Tests for class b:                 Hypothesis  Estimate Est.Error  CI.Lower  CI.Upper Evid.Ratio 1 (treatmentunimpac... = 0 -58137442  19952480 -97621677 -18695671         NA   Post.Prob Star 1        NA    * --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities."},{"path":"https://marine-ecologist.github.io/reefspawn/articles/experimental.html","id":"larval-development","dir":"Articles","previous_headings":"","what":"Larval development","title":"Experimental results","text":"strong evidence treatment effect spathulata. Estimate 456.2 [–483.5, +1409.8] strong evidence treatment effect hyacinthus. Estimate –456.21 [–1409.84, 430.191]","code":"#| class-source: fold-hide #| message: false #| warning: false #| fig-width: 9.5 #| fig-height: 5   string_treatment <- c(rep(\"S1\",3), rep(\"N2\", 3), rep(\"S2\", 3), rep(\"N1\", 3))   onboard_cultures <- readxl::read_excel(\"/Users/rof011/reefspawn/code/SurvExpData.xlsx\", sheet = \"OnboardCulture\") |>   janitor::clean_names() |>   # clean up time   dplyr::mutate(time = as.POSIXct(samping_date, format = \"%d/%m/%Y\", tz = \"UTC\")) |>   dplyr::mutate(time = as.numeric(difftime(time, min(time), units = \"days\"))) |>   # clean up ID   #dplyr::filter(!is.na(treatment_id)) |>   dplyr::mutate(treatment = stringr::str_remove(treatment_id, \"^Tank_\")) |>   dplyr::mutate(sample_prefix = ifelse(is.na(sample_id), NA, substr(sample_id, 1, 2))) |>   dplyr::mutate(treatment = ifelse(is.na(treatment_id), sample_prefix, treatment_id)) %>%  # replace missing treatment_id with sample_prefix, check seperately   dplyr::filter(treatment %in% c(\"N1\", \"N2\", \"S1\", \"S2\")) %>%   mutate(rep = rep(c(\"a\", \"b\", \"c\"), (nrow(.)/3))) |>   select(treatment, time, deformed, normal, total_larvae) |>   group_by(treatment, time) |>   summarise(deformed = mean(deformed), normal = mean(normal), total_larvae = mean(total_larvae)) |>   dplyr::mutate(species = dplyr::case_when(     stringr::str_detect(treatment, \"1$\") ~ \"hyacinthus\",     stringr::str_detect(treatment, \"2$\") ~ \"spathulata\",     TRUE ~ NA_character_   )) |>   dplyr::mutate(var = paste0(species, \"_\", treatment)) |>   tidyr::separate(var, into = c(\"species\", \"treatment\"), sep = \"_\") |>   dplyr::mutate(condition = dplyr::case_when(     stringr::str_detect(treatment, \"^N\") ~ \"unimpacted\",     stringr::str_detect(treatment, \"^S\") ~ \"impacted\",     TRUE ~ NA_character_   )) |>   mutate(total_larvae = (total_larvae/16) * 1000) |>    mutate(treatment = condition)  # quadratic_counts <- brm( #   total_larvae ~ time + I(time^2) * treatment * species, #   data = onboard_cultures, #   family = gaussian(), #   chains = 4, cores = 4 # )  # saveRDS(quadratic_counts, \"/Users/rof011/reefspawn/code/quadratic_counts.rds\")  quadratic_counts <- readRDS(\"/Users/rof011/reefspawn/code/quadratic_counts.rds\")   # Expand prediction grid with full interaction structure newdata <- tidyr::expand_grid(   time = seq(min(onboard_cultures$time), max(onboard_cultures$time), length.out = 100),   treatment = unique(onboard_cultures$treatment),   species = unique(onboard_cultures$species) )  # Get predicted values with uncertainty quad_fitted <- fitted(   quadratic_counts,   newdata = newdata,   scale = \"response\",   allow_new_levels = TRUE ) |> as_tibble()  # Combine predictions newdata_quad <- bind_cols(newdata, quad_fitted)  # Add condition back (if needed for fill/color) newdata_quad <- newdata_quad |>   left_join(onboard_cultures |> distinct(treatment, species, condition), by = c(\"treatment\", \"species\"))  # Plot plot_c <- ggplot() +   theme_bw() +   facet_wrap(~ species) +   geom_ribbon(data = newdata_quad, aes(x = time, ymin = Q2.5, ymax = Q97.5, fill = condition),               alpha = 0.5, show.legend = FALSE) +   geom_line(data = newdata_quad, aes(x = time, y = Estimate, color = condition),             linewidth = 1.2, show.legend = FALSE) +   geom_line(data = onboard_cultures, aes(x = time, y = total_larvae, color = condition),             linetype = \"dashed\", show.legend = FALSE) +   geom_point(data = onboard_cultures, aes(x = time, y = total_larvae, fill = condition),              shape = 21, color = \"black\", size = 2, alpha = 0.9, show.legend = FALSE) +   labs(     title = \"Quadratic fit of larval counts over time\",     y = \"n larvae / litre\",     x = \"Time (days)\"   ) +   scale_fill_manual(values = c(\"navajowhite\", \"paleturquoise\")) +   scale_color_manual(values = c(\"navajowhite3\", \"paleturquoise3\")) +   coord_cartesian(ylim = c(0, 2500))   plot_c hypothesis(quadratic_counts, \"treatmentunimpacted + ItimeE2:treatmentunimpacted = 0\") Hypothesis Tests for class b:                 Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio 1 (treatmentunimpac... = 0   215.11    457.61  -717.78   1165.8         NA   Post.Prob Star 1        NA --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities. hypothesis(quadratic_counts,   \"treatmentunimpacted +    ItimeE2:treatmentunimpacted +    treatmentunimpacted:speciesspathulata +    ItimeE2:treatmentunimpacted:speciesspathulata = 0\") Hypothesis Tests for class b:                 Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio 1 (treatmentunimpac... = 0  -483.54    456.21 -1409.84   430.19         NA   Post.Prob Star 1        NA --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities."},{"path":"https://marine-ecologist.github.io/reefspawn/articles/experimental.html","id":"larval-settlement-5-days","dir":"Articles","previous_headings":"","what":"Larval settlement (5 days)","title":"Experimental results","text":"evidence unimpacted reefs lower settler counts impacted reefs. effect size large (–87), uncertain — CI includes small positive values Estimate -87.5 [–176.6, +4.7]","code":"#| class-source: fold-hide #| message: false #| warning: false #| fig-width: 9.5 #| fig-height: 5    tiles <- readxl::read_excel(\"/Users/rof011/reefspawn/code/SurvExpData.xlsx\", sheet = \"SetTilesSurvREEF_cleaned\") |>   janitor::clean_names() |>   mutate(days = date_scored - date_tile_deployment) |>   group_by(plot_id, days, tile_face, treatment, tile_number) |>   summarise(total_count = sum(settler_count)) |>   mutate(days = as.numeric(days)) |>   mutate(days = ifelse(days <100, \"5 days\", \"110 days\")) |>   mutate(days = as.factor(days)) |>   filter(treatment %in% c(\"Normal\", \"Survivor\")) |>   dplyr::mutate(     treatment = dplyr::case_when(       stringr::str_detect(treatment, \"Survivor\") ~ \"impacted\",       stringr::str_detect(treatment, \"Normal\") ~ \"unimpacted\",       TRUE ~ NA_character_     )   )   tiles_grouped <- tiles |>   group_by(days, treatment, plot_id, tile_number) |>   summarise(total_count = sum(total_count))  tiles_grouped_mean <- tiles_grouped |>   group_by(days, treatment) |>   summarise(total_count = mean(total_count))  ### first timepoint  tiles_counts_a <- brm(   total_count ~ treatment + (1|plot_id),   data = tiles_grouped |> filter(days == \"5 days\"),   family = gaussian(),   chains = 4, cores = 4 )  # saveRDS(tiles_counts_a, \"/Users/rof011/reefspawn/code/tiles_counts_a.rds\")  tiles_counts_a <- readRDS(\"/Users/rof011/reefspawn/code/tiles_counts_a.rds\")  # Create prediction grid tiles_counts_a_newdata <- expand.grid(   treatment = unique(tiles_grouped$treatment),   plot_id = NA  # marginalize over random effect )  # Get fitted values on response scale with uncertainty tiles_counts_a_fitted_vals <- fitted(tiles_counts_a, newdata = tiles_counts_a_newdata, scale = \"response\", allow_new_levels = TRUE) |> as_tibble() tiles_counts_a_newdata <- bind_cols(tiles_counts_a_newdata, tiles_counts_a_fitted_vals)  # # ggplot() + #   theme_bw() + #   geom_point(data = tiles_grouped |> filter(days == \"5 days\"), aes(x = treatment, y = total_count, fill = treatment), #              shape = 21, color = \"black\", alpha = 0.5, size = 2, position = position_jitter(width = 0.1)) + #   geom_pointrange(data = tiles_counts_a_newdata, #                   aes(x = treatment, y = Estimate, ymin = Q2.5, ymax = Q97.5, fill = treatment), #                   shape = 21, color = \"black\", size = 1.2) + #   labs(title = \"Predicted settler counts by treatment (ZIP model)\", #        y = \"Predicted count (mean ± 95% CI)\", x = \"Treatment\") + #   scale_fill_manual(values = c(\"paleturquoise\", \"navajowhite\"))  tileplot_a <- ggplot() + theme_bw() + facet_wrap(~days) +   geom_violin(data = tiles_grouped |> filter(days == \"5 days\"), aes(treatment, total_count, fill=treatment), linewidth=0.25, alpha=0.2, show.legend = FALSE) +   geom_jitter(data = tiles_grouped |> filter(days == \"5 days\"), aes(treatment, total_count), width=0.1, size=0.4, alpha=0.2, show.legend = FALSE) +   geom_pointrange(data = tiles_counts_a_newdata,                   aes(x = treatment, y = Estimate, ymin = Q2.5, ymax = Q97.5, fill = treatment),                   shape = 21, linewidth=0.5, color = \"black\", size = 0.6, show.legend = FALSE) +   scale_fill_manual(values = c(\"paleturquoise\", \"navajowhite\")) + ylab(\"Larvae per tile\")  tileplot_a hypothesis(tiles_counts_a, \"treatmentunimpacted = 0\") Hypothesis Tests for class b:                 Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio 1 (treatmentunimpac... = 0   -87.49     47.36  -176.56     4.67         NA   Post.Prob Star 1        NA --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities."},{"path":"https://marine-ecologist.github.io/reefspawn/articles/experimental.html","id":"larval-recruitment-3-months","dir":"Articles","previous_headings":"","what":"Larval recruitment (3 months)","title":"Experimental results","text":"strong evidence treatment effect Estimate 0.52 [–1.42, +0.43]","code":"#| class-source: fold-hide #| message: false #| warning: false #| fig-width: 9.5 #| fig-height: 5   # tiles_counts_b <- brm( #   total_count ~ treatment + (1|plot_id), #   data = tiles_grouped |> filter(days == \"110 days\"), #   family = zero_inflated_poisson(), #   chains = 4, cores = 4, adapt_delta = 0.95: # ) # # saveRDS(tiles_counts_b, \"/Users/rof011/reefspawn/code/tiles_counts_b.rds\")  tiles_counts_b <- readRDS(\"/Users/rof011/reefspawn/code/tiles_counts_b.rds\")   # Create prediction grid tiles_counts_b_newdata <- expand.grid(   treatment = unique(tiles_grouped$treatment),   plot_id = NA  # marginalize over random effect )  # Get fitted values on response scale with uncertainty tiles_counts_b_fitted_vals <- fitted(tiles_counts_b, newdata = tiles_counts_b_newdata, scale = \"response\", allow_new_levels = TRUE) |> as_tibble() tiles_counts_b_newdata <- bind_cols(tiles_counts_b_newdata, tiles_counts_b_fitted_vals)  # # tileplot_b <- ggplot() + #   theme_bw() + #   geom_point(data = tiles_grouped |> filter(days == \"5 days\"), aes(x = treatment, y = total_count, fill = treatment), #              shape = 21, color = \"black\", alpha = 0.5, size = 2, position = position_jitter(width = 0.1)) + #   geom_pointrange(data = tiles_counts_b_newdata, #                   aes(x = treatment, y = Estimate, ymin = Q2.5, ymax = Q97.5, fill = treatment), #                   shape = 21, color = \"black\", size = 1.2) + #   labs(title = \"Predicted settler counts by treatment (ZIP model)\", #        y = \"Predicted count (mean ± 95% CI)\", x = \"Treatment\") + #   scale_fill_manual(values = c(\"paleturquoise\", \"navajowhite\"))  tileplot_b <- ggplot() + theme_bw() + facet_wrap(~days) +   geom_violin(data = tiles_grouped |> filter(days == \"110 days\"), aes(treatment, total_count, fill=treatment), linewidth=0.25, alpha=0.2, show.legend = FALSE) +   geom_jitter(data = tiles_grouped |> filter(days == \"110 days\"), aes(treatment, total_count), width=0.1, size=0.4, alpha=0.2, show.legend = FALSE) +   geom_pointrange(data = tiles_counts_b_newdata,                   aes(x = treatment, y = Estimate, ymin = Q2.5, ymax = Q97.5, fill = treatment),                   shape = 21, linewidth=0.5, stroke = 0.5, color = \"black\", size = 0.6, show.legend = FALSE) +   scale_fill_manual(values = c(\"paleturquoise\", \"navajowhite\")) + ylab(\"Larvae per tile\")  tileplot_b hypothesis(tiles_counts_b, \"treatmentunimpacted = 0\") Hypothesis Tests for class b:                 Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio 1 (treatmentunimpac... = 0    -0.52      0.47    -1.42     0.43         NA   Post.Prob Star 1        NA --- 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses. '*': For one-sided hypotheses, the posterior probability exceeds 95%; for two-sided hypotheses, the value tested against lies outside the 95%-CI. Posterior probabilities of point hypotheses assume equal prior probabilities."},{"path":"https://marine-ecologist.github.io/reefspawn/articles/experimental.html","id":"posterior-predictions","dir":"Articles","previous_headings":"","what":"Posterior predictions","title":"Experimental results","text":"proportional effect sizes, calculated : Effect size=(impactedunimpacted)−1 \\text{Effect size} = \\left( \\frac{\\text{impacted}}{\\text{unimpacted}} \\right) - 1 :  cumulative effect size product individual stage posteriors: Cumulative effect=∏=1n(impactediunimpactedi)−1 \\text{Cumulative effect} = \\displaystyle\\prod_{=1}^n \\left( \\frac{\\text{impacted}_i}{\\text{unimpacted}_i} \\right) - 1","code":"•   1 = no effect (impacted = unimpacted) •   <1 = negative effect (impacted < unimpacted) •   >1 = positive effect (impacted > unimpacted) ############################## ##### fm_egg_size ##############################  posterior <- as.data.frame(fm_egg_size) mu_hyacinthus_impacted <- posterior$b_Intercept mu_hyacinthus_unimpacted <- posterior$b_Intercept + posterior$b_treatmentunimpacted mu_spathulata_impacted <- posterior$b_Intercept + posterior$`b_speciesspathulatha` mu_spathulata_unimpacted <- mu_spathulata_impacted +   posterior$`b_treatmentunimpacted` +   posterior$`b_treatmentunimpacted:speciesspathulatha`  rel_pct_hyacinthus <- (mu_hyacinthus_impacted / mu_hyacinthus_unimpacted) rel_pct_spathulata <- (mu_spathulata_impacted / mu_spathulata_unimpacted)  fm_egg_size_posterior <- tibble(   species = c(\"hyacinthus\", \"spathulata\"),   effect_size = c(mean(rel_pct_hyacinthus), mean(rel_pct_spathulata)) - 1,   effect_lower = c(quantile(rel_pct_hyacinthus, 0.025), quantile(rel_pct_spathulata, 0.025)) - 1,   effect_upper = c(quantile(rel_pct_hyacinthus, 0.975), quantile(rel_pct_spathulata, 0.975)) - 1 ) |> mutate(stage = \"1. oocyte size\")   ############################## ##### fm_reproductive_output ##############################  posterior_repro <- as.data.frame(fm_reproductive_output) mu_hyacinthus_impacted <- posterior_repro$b_Intercept mu_hyacinthus_unimpacted <- posterior_repro$b_Intercept + posterior_repro$b_treatmentunimpacted mu_spathulata_impacted <- posterior_repro$b_Intercept + posterior_repro$`b_speciesspathulatha` mu_spathulata_unimpacted <- mu_spathulata_impacted +   posterior_repro$`b_treatmentunimpacted` +   posterior_repro$`b_treatmentunimpacted:speciesspathulatha`  rel_pct_hyacinthus <- (mu_hyacinthus_impacted / mu_hyacinthus_unimpacted) rel_pct_spathulata <- (mu_spathulata_impacted / mu_spathulata_unimpacted)  fm_repro_posterior <- tibble(   species = c(\"hyacinthus\", \"spathulata\"),   effect_size = c(mean(rel_pct_hyacinthus), mean(rel_pct_spathulata)) - 1,   effect_lower = c(quantile(rel_pct_hyacinthus, 0.025), quantile(rel_pct_spathulata, 0.025)) - 1,   effect_upper = c(quantile(rel_pct_hyacinthus, 0.975), quantile(rel_pct_spathulata, 0.975)) - 1 ) |> mutate(stage = \"2. reproductive biomass\")   ############################## ##### larval development ##############################  posterior <- as.data.frame(quadratic_counts) time <- 1.5 time2 <- time^2  mu_h_impacted <- posterior$b_Intercept + posterior$b_time * time + posterior$`b_ItimeE2` * time2 mu_h_unimpacted <- mu_h_impacted + posterior$`b_treatmentunimpacted` + posterior$`b_ItimeE2:treatmentunimpacted` * time2 mu_s_impacted <- mu_h_impacted + posterior$`b_speciesspathulata` + posterior$`b_ItimeE2:speciesspathulata` * time2 mu_s_unimpacted <- mu_s_impacted +   posterior$`b_treatmentunimpacted` +   posterior$`b_ItimeE2:treatmentunimpacted` * time2 +   posterior$`b_treatmentunimpacted:speciesspathulata` +   posterior$`b_ItimeE2:treatmentunimpacted:speciesspathulata` * time2  rel_pct_h <- mu_h_impacted /mu_h_unimpacted rel_pct_s <- mu_s_impacted / mu_s_unimpacted   quadratic_counts_posterior <- tibble(   species = c(\"hyacinthus\", \"spathulata\"),   effect_size = c(mean(rel_pct_h), mean(rel_pct_s)) - 1,   effect_lower = c(quantile(rel_pct_h, 0.025), quantile(rel_pct_s, 0.025)) - 1,   effect_upper = c(quantile(rel_pct_h, 0.975), quantile(rel_pct_s, 0.975)) - 1 ) |> mutate(stage = \"3. larval development\")   ############################## ##### larval settlement ##############################  posterior <- as.data.frame(tiles_counts_a) mu_impacted <- posterior$b_Intercept mu_unimpacted <- mu_impacted + posterior$b_treatmentunimpacted rel_pct <- mu_impacted/ mu_unimpacted   tiles_counts_a_posterior <- tibble(   effect_size = mean(rel_pct) - 1,   effect_lower = quantile(rel_pct, 0.025) - 1,   effect_upper = quantile(rel_pct, 0.975) - 1,   species = NA,   stage = \"4. larval settlement\" )   ############################## ##### larval recruitment ##############################  posterior <- as.data.frame(tiles_counts_b) log_mu_impacted <- posterior$b_Intercept log_mu_unimpacted <- log_mu_impacted + posterior$b_treatmentunimpacted mu_impacted <- exp(log_mu_impacted) mu_unimpacted <- exp(log_mu_unimpacted) rel_pct <-  mu_impacted / mu_unimpacted  tiles_counts_b_posterior <- tibble(   effect_size = mean(rel_pct) - 1,   effect_lower = quantile(rel_pct, 0.025) - 1,   effect_upper = quantile(rel_pct, 0.975) - 1,   species = NA,   stage = \"5. larval recruitment\" )   ############################## ##### Combine ##############################  posterior_prediction_table <- bind_rows(   fm_egg_size_posterior,   fm_repro_posterior,   quadratic_counts_posterior,   tiles_counts_a_posterior,   tiles_counts_b_posterior ) |>   mutate(across(c(effect_size, effect_lower, effect_upper), ~ round(.x, 1))) |>    mutate(across(c(effect_size, effect_lower, effect_upper), ~ as.numeric(.x))) |>    mutate(species = ifelse(is.na(species), \"pooled\", species)) |>    select(stage, species, effect_size, effect_lower, effect_upper) |>    arrange(stage, species)   blankdf <- data.frame(     stage =c(\"4. larval settlement\",  \"5. larval recruitment\"),     species = NA, effect_size = NA, effect_lower = NA, effect_upper = NA)   DT::datatable(   posterior_prediction_table,   rownames = FALSE,   options = list(     pageLength = 10,     autoWidth = TRUE,     dom = 't'   ),   class = 'stripe hover compact',   escape = FALSE ) %>%   DT::formatStyle(     columns = names(posterior_prediction_table),     fontSize = '70%'   ) %>%   DT::formatStyle(     'stage',     target = 'row',     backgroundColor = DT::styleEqual(       unique(posterior_prediction_table$stage),       gray.colors(length(unique(posterior_prediction_table$stage)), start = 0.9, end = 0.7)     )   ) posterior_prediction_table_full <- rbind(posterior_prediction_table, blankdf)  posterior_predicts <- ggplot() +     theme_bw() +    facet_grid(~stage, scales = \"free\") +   geom_col(data = posterior_prediction_table_full,             aes(x = stage, y = effect_size, group = species, fill = species),             position = position_dodge(width = 0.45), width = 0.4, col=\"black\", linewidth=0.2) +   geom_errorbar(data = posterior_prediction_table_full,                  aes(x = stage, y = effect_size, group = species, ymin = effect_lower, ymax = effect_upper),                 width = 0.1, position = position_dodge(width = 0.45)) +   scale_y_continuous(limits = c(-2.5, 2.5), breaks=c(-2, -1, 1, 2), oob = scales::oob_keep) +   labs(x = NULL, y = \"Effect size (log scale difference)\", fill = \"Species\") +   geom_hline(yintercept = 0, linewidth=0.2) +   theme(panel.grid.major.x = element_blank(),         panel.grid.minor.x = element_blank())  posterior_predicts #ggsave(posterior_predicts,filename=\"/Users/rof011/reefspawn/code/posterior_predicts.pdf\", width=6, height=2) posterior_prediction_table <- bind_rows(   fm_egg_size_posterior,   fm_repro_posterior,   quadratic_counts_posterior,   tiles_counts_a_posterior,   tiles_counts_b_posterior ) |>   mutate(across(c(effect_size, effect_lower, effect_upper), ~ round(.x, 1))) |>    mutate(across(c(effect_size, effect_lower, effect_upper), ~ as.numeric(.x))) |>    mutate(species = ifelse(is.na(species), \"pooled\", species)) |>    select(stage, species, effect_size, effect_lower, effect_upper) |>    arrange(stage, species)   pooled_vals <- posterior_prediction_table |>   filter(species == \"pooled\")  blankdf <- pooled_vals |>   slice(rep(1:n(), each = 2)) |>   mutate(species = rep(c(\"hyacinthus\", \"spathulata\"), times = nrow(pooled_vals)))  posterior_prediction_table <- rbind(posterior_prediction_table |> filter(!species==\"pooled\"), blankdf) |>    arrange(stage, species)  posterior_prediction_table_wider <- posterior_prediction_table |>    select(stage, species, effect_size) |>    pivot_wider(names_from = \"stage\", values_from = \"effect_size\") |>    rename(oocyte=2, biomass=3, larvae=4, settlement=5, recruitment=6) |>    mutate(probability = oocyte*biomass*larvae*settlement*recruitment)   #### posterior  # ======================== # 1. Extract posteriors # ========================  posterior_egg     <- as.data.frame(fm_egg_size) posterior_repro   <- as.data.frame(fm_reproductive_output) posterior_dev     <- as.data.frame(quadratic_counts) posterior_settle  <- as.data.frame(tiles_counts_a) posterior_recruit <- as.data.frame(tiles_counts_b)  # ======================== # 2. Posterior ratios # ========================  ## Egg size rel_pct_egg_h <- posterior_egg$b_Intercept / (posterior_egg$b_Intercept + posterior_egg$b_treatmentunimpacted) rel_pct_egg_s <- (posterior_egg$b_Intercept + posterior_egg$`b_speciesspathulatha`) /   (posterior_egg$b_Intercept + posterior_egg$`b_speciesspathulatha` +    posterior_egg$b_treatmentunimpacted + posterior_egg$`b_treatmentunimpacted:speciesspathulatha`)  ## Reproductive output rel_pct_repro_h <- posterior_repro$b_Intercept / (posterior_repro$b_Intercept + posterior_repro$b_treatmentunimpacted) rel_pct_repro_s <- (posterior_repro$b_Intercept + posterior_repro$`b_speciesspathulatha`) /   (posterior_repro$b_Intercept + posterior_repro$`b_speciesspathulatha` +    posterior_repro$b_treatmentunimpacted + posterior_repro$`b_treatmentunimpacted:speciesspathulatha`)  ## Larval development time <- 1.5 time2 <- time^2 mu_h_impacted <- posterior_dev$b_Intercept + posterior_dev$b_time * time + posterior_dev$`b_ItimeE2` * time2 mu_h_unimpacted <- mu_h_impacted + posterior_dev$b_treatmentunimpacted + posterior_dev$`b_ItimeE2:treatmentunimpacted` * time2  mu_s_impacted <- mu_h_impacted + posterior_dev$`b_speciesspathulata` + posterior_dev$`b_ItimeE2:speciesspathulata` * time2 mu_s_unimpacted <- mu_s_impacted +   posterior_dev$b_treatmentunimpacted +   posterior_dev$`b_ItimeE2:treatmentunimpacted` * time2 +   posterior_dev$`b_treatmentunimpacted:speciesspathulata` +   posterior_dev$`b_ItimeE2:treatmentunimpacted:speciesspathulata` * time2  rel_pct_dev_h <- mu_h_impacted / mu_h_unimpacted rel_pct_dev_s <- mu_s_impacted / mu_s_unimpacted  ## Settlement (pooled) rel_pct_settle <- posterior_settle$b_Intercept / (posterior_settle$b_Intercept + posterior_settle$b_treatmentunimpacted)  ## Recruitment (pooled, log-link) mu_impacted <- exp(posterior_recruit$b_Intercept) mu_unimpacted <- exp(posterior_recruit$b_Intercept + posterior_recruit$b_treatmentunimpacted) rel_pct_recruit <- mu_impacted / mu_unimpacted  # ======================== # 3. Combine and summarise # ========================  combined_draws_h <- mean(rel_pct_egg_h) * mean(rel_pct_repro_h) * mean(rel_pct_dev_h) * mean(rel_pct_settle) * mean(rel_pct_recruit) /5  combined_draws_s <- mean(rel_pct_egg_s) * mean(rel_pct_repro_s) * mean(rel_pct_dev_s) * mean(rel_pct_settle) * mean(rel_pct_recruit) /5   posterior_cumulative <- tibble(   species = c(\"hyacinthus\", \"spathulata\"),   oocyte_size = c(mean(rel_pct_egg_h), mean(rel_pct_egg_s)),   reproductive_biomass = c(mean(rel_pct_repro_h), mean(rel_pct_repro_s)),   larval_development = c(mean(rel_pct_dev_h), mean(rel_pct_dev_s)),   larval_settlement = c(mean(rel_pct_settle), mean(rel_pct_settle)),   larval_recruitment = c(mean(rel_pct_recruit), mean(rel_pct_recruit)),   cumulative_effect_size = c(mean(combined_draws_h - 1), mean(combined_draws_s - 1)),   cumulative_effect_lower = c(quantile(combined_draws_h - 1, 0.025), quantile(combined_draws_s - 1, 0.025)),   cumulative_effect_upper = c(quantile(combined_draws_h - 1, 0.975), quantile(combined_draws_s - 1, 0.975)) ) |>   mutate(across(where(is.numeric), round, 1)) |>    select(-cumulative_effect_lower, -cumulative_effect_upper)  posterior_cumulative |>   DT::datatable(     options = list(       pageLength = 5,       autoWidth = TRUE,       dom = 't',       columnDefs = list(         list(className = 'dt-center', targets = \"_all\")       )     ),     rownames = FALSE   ) %>%   DT::formatStyle(     columns = names(posterior_cumulative),     fontSize = '70%'   ) %>%   DT::formatStyle(     'species',     target = 'row',     backgroundColor = DT::styleEqual(       unique(posterior_cumulative$species),       gray.colors(length(unique(posterior_cumulative$species)), start = 0.9, end = 0.8)     )   ) #| class-source: fold-hide #| message: false #| warning: false #| fig-width: 10 #| fig-height: 2 #|    p <- (a + ggtitle(\"\") | b + ggtitle(\"\") | plot_c + ggtitle(\"\") | tileplot_a + ggtitle(\"\") | tileplot_b + ggtitle(\"\"))  ggsave(\"/Users/rof011/reefspawn/code/patchwork_plot.png\", plot = p, width = 50, height = 5, units = \"in\", dpi = 300, limitsize = FALSE)  #knitr::include_graphics(\"/Users/rof011/reefspawn/code/patchwork_plot.png\")  library(patchwork) •   1 = no effect (impacted = unimpacted) •   <1 = negative effect (impacted < unimpacted) •   >1 = positive effect (impacted > unimpacted)"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/experimental.html","id":"i-effect-sizes-impacted-vs-unimpacted","dir":"Articles","previous_headings":"","what":"i) effect sizes (impacted vs unimpacted)","title":"Experimental results","text":"proportional effect sizes, calculated : Effect size=(impactedunimpacted)−1 \\text{Effect size} = \\left( \\frac{\\text{impacted}}{\\text{unimpacted}} \\right) - 1 :","code":"•   1 = no effect (impacted = unimpacted) •   <1 = negative effect (impacted < unimpacted) •   >1 = positive effect (impacted > unimpacted) ############################## ##### fm_egg_size ##############################  posterior <- as.data.frame(fm_egg_size) mu_hyacinthus_impacted <- posterior$b_Intercept mu_hyacinthus_unimpacted <- posterior$b_Intercept + posterior$b_treatmentunimpacted mu_spathulata_impacted <- posterior$b_Intercept + posterior$`b_speciesspathulatha` mu_spathulata_unimpacted <- mu_spathulata_impacted +   posterior$`b_treatmentunimpacted` +   posterior$`b_treatmentunimpacted:speciesspathulatha`  rel_pct_hyacinthus <- (mu_hyacinthus_impacted / mu_hyacinthus_unimpacted) rel_pct_spathulata <- (mu_spathulata_impacted / mu_spathulata_unimpacted)  fm_egg_size_posterior <- tibble(   species = c(\"hyacinthus\", \"spathulata\"),   effect_size = c(mean(rel_pct_hyacinthus), mean(rel_pct_spathulata)) - 1,   effect_lower = c(quantile(rel_pct_hyacinthus, 0.025), quantile(rel_pct_spathulata, 0.025)) - 1,   effect_upper = c(quantile(rel_pct_hyacinthus, 0.975), quantile(rel_pct_spathulata, 0.975)) - 1 ) |> mutate(stage = \"1. oocyte size\")   ############################## ##### fm_reproductive_output ##############################  posterior_repro <- as.data.frame(fm_reproductive_output) mu_hyacinthus_impacted <- posterior_repro$b_Intercept mu_hyacinthus_unimpacted <- posterior_repro$b_Intercept + posterior_repro$b_treatmentunimpacted mu_spathulata_impacted <- posterior_repro$b_Intercept + posterior_repro$`b_speciesspathulatha` mu_spathulata_unimpacted <- mu_spathulata_impacted +   posterior_repro$`b_treatmentunimpacted` +   posterior_repro$`b_treatmentunimpacted:speciesspathulatha`  rel_pct_hyacinthus <- (mu_hyacinthus_impacted / mu_hyacinthus_unimpacted) rel_pct_spathulata <- (mu_spathulata_impacted / mu_spathulata_unimpacted)  fm_repro_posterior <- tibble(   species = c(\"hyacinthus\", \"spathulata\"),   effect_size = c(mean(rel_pct_hyacinthus), mean(rel_pct_spathulata)) - 1,   effect_lower = c(quantile(rel_pct_hyacinthus, 0.025), quantile(rel_pct_spathulata, 0.025)) - 1,   effect_upper = c(quantile(rel_pct_hyacinthus, 0.975), quantile(rel_pct_spathulata, 0.975)) - 1 ) |> mutate(stage = \"2. reproductive biomass\")   ############################## ##### larval development ##############################  posterior <- as.data.frame(quadratic_counts) time <- 1.5 time2 <- time^2  mu_h_impacted <- posterior$b_Intercept + posterior$b_time * time + posterior$`b_ItimeE2` * time2 mu_h_unimpacted <- mu_h_impacted + posterior$`b_treatmentunimpacted` + posterior$`b_ItimeE2:treatmentunimpacted` * time2 mu_s_impacted <- mu_h_impacted + posterior$`b_speciesspathulata` + posterior$`b_ItimeE2:speciesspathulata` * time2 mu_s_unimpacted <- mu_s_impacted +   posterior$`b_treatmentunimpacted` +   posterior$`b_ItimeE2:treatmentunimpacted` * time2 +   posterior$`b_treatmentunimpacted:speciesspathulata` +   posterior$`b_ItimeE2:treatmentunimpacted:speciesspathulata` * time2  rel_pct_h <- mu_h_impacted /mu_h_unimpacted rel_pct_s <- mu_s_impacted / mu_s_unimpacted   quadratic_counts_posterior <- tibble(   species = c(\"hyacinthus\", \"spathulata\"),   effect_size = c(mean(rel_pct_h), mean(rel_pct_s)) - 1,   effect_lower = c(quantile(rel_pct_h, 0.025), quantile(rel_pct_s, 0.025)) - 1,   effect_upper = c(quantile(rel_pct_h, 0.975), quantile(rel_pct_s, 0.975)) - 1 ) |> mutate(stage = \"3. larval development\")   ############################## ##### larval settlement ##############################  posterior <- as.data.frame(tiles_counts_a) mu_impacted <- posterior$b_Intercept mu_unimpacted <- mu_impacted + posterior$b_treatmentunimpacted rel_pct <- mu_impacted/ mu_unimpacted   tiles_counts_a_posterior <- tibble(   effect_size = mean(rel_pct) - 1,   effect_lower = quantile(rel_pct, 0.025) - 1,   effect_upper = quantile(rel_pct, 0.975) - 1,   species = NA,   stage = \"4. larval settlement\" )   ############################## ##### larval recruitment ##############################  posterior <- as.data.frame(tiles_counts_b) log_mu_impacted <- posterior$b_Intercept log_mu_unimpacted <- log_mu_impacted + posterior$b_treatmentunimpacted mu_impacted <- exp(log_mu_impacted) mu_unimpacted <- exp(log_mu_unimpacted) rel_pct <-  mu_impacted / mu_unimpacted  tiles_counts_b_posterior <- tibble(   effect_size = mean(rel_pct) - 1,   effect_lower = quantile(rel_pct, 0.025) - 1,   effect_upper = quantile(rel_pct, 0.975) - 1,   species = NA,   stage = \"5. larval recruitment\" )   ############################## ##### Combine ##############################  posterior_prediction_table <- bind_rows(   fm_egg_size_posterior,   fm_repro_posterior,   quadratic_counts_posterior,   tiles_counts_a_posterior,   tiles_counts_b_posterior ) |>   mutate(across(c(effect_size, effect_lower, effect_upper), ~ round(.x, 1))) |>    mutate(across(c(effect_size, effect_lower, effect_upper), ~ as.numeric(.x))) |>    mutate(species = ifelse(is.na(species), \"pooled\", species)) |>    select(stage, species, effect_size, effect_lower, effect_upper) |>    arrange(stage, species)   blankdf <- data.frame(     stage =c(\"4. larval settlement\",  \"5. larval recruitment\"),     species = NA, effect_size = NA, effect_lower = NA, effect_upper = NA)   DT::datatable(   posterior_prediction_table,   rownames = FALSE,   options = list(     pageLength = 10,     autoWidth = TRUE,     dom = 't'   ),   class = 'stripe hover compact',   escape = FALSE ) %>%   DT::formatStyle(     columns = names(posterior_prediction_table),     fontSize = '70%'   ) %>%   DT::formatStyle(     'stage',     target = 'row',     backgroundColor = DT::styleEqual(       unique(posterior_prediction_table$stage),       gray.colors(length(unique(posterior_prediction_table$stage)), start = 0.9, end = 0.7)     )   ) posterior_prediction_table_full <- rbind(posterior_prediction_table, blankdf)  posterior_predicts <- ggplot() +     theme_bw() +    facet_grid(~stage, scales = \"free\") +   geom_col(data = posterior_prediction_table_full,             aes(x = stage, y = effect_size, group = species, fill = species),             position = position_dodge(width = 0.45), width = 0.4, col=\"black\", linewidth=0.2) +   geom_errorbar(data = posterior_prediction_table_full,                  aes(x = stage, y = effect_size, group = species, ymin = effect_lower, ymax = effect_upper),                 width = 0.1, position = position_dodge(width = 0.45)) +   scale_y_continuous(limits = c(-2.5, 2.5), breaks=c(-2, -1, 1, 2), oob = scales::oob_keep) +   labs(x = NULL, y = \"Effect size (log scale difference)\", fill = \"Species\") +   geom_hline(yintercept = 0, linewidth=0.2) +   theme(panel.grid.major.x = element_blank(),         panel.grid.minor.x = element_blank())  posterior_predicts #ggsave(posterior_predicts,filename=\"/Users/rof011/reefspawn/code/posterior_predicts.pdf\", width=6, height=2)"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/experimental.html","id":"ii-cumulative-effects-across-life-history-stages","dir":"Articles","previous_headings":"","what":"ii) cumulative effects across life history stages","title":"Experimental results","text":"cumulative effect size product individual stage posteriors: Cumulative effect=∏=1n(impactediunimpactedi)−1 \\text{Cumulative effect} = \\displaystyle\\prod_{=1}^n \\left( \\frac{\\text{impacted}_i}{\\text{unimpacted}_i} \\right) - 1","code":"posterior_prediction_table <- bind_rows(   fm_egg_size_posterior,   fm_repro_posterior,   quadratic_counts_posterior,   tiles_counts_a_posterior,   tiles_counts_b_posterior ) |>   mutate(across(c(effect_size, effect_lower, effect_upper), ~ round(.x, 1))) |>    mutate(across(c(effect_size, effect_lower, effect_upper), ~ as.numeric(.x))) |>    mutate(species = ifelse(is.na(species), \"pooled\", species)) |>    select(stage, species, effect_size, effect_lower, effect_upper) |>    arrange(stage, species)   pooled_vals <- posterior_prediction_table |>   filter(species == \"pooled\")  blankdf <- pooled_vals |>   slice(rep(1:n(), each = 2)) |>   mutate(species = rep(c(\"hyacinthus\", \"spathulata\"), times = nrow(pooled_vals)))  posterior_prediction_table <- rbind(posterior_prediction_table |> filter(!species==\"pooled\"), blankdf) |>    arrange(stage, species)  posterior_prediction_table_wider <- posterior_prediction_table |>    select(stage, species, effect_size) |>    pivot_wider(names_from = \"stage\", values_from = \"effect_size\") |>    rename(oocyte=2, biomass=3, larvae=4, settlement=5, recruitment=6) |>    mutate(probability = oocyte*biomass*larvae*settlement*recruitment)   #### posterior  # ======================== # 1. Extract posteriors # ========================  posterior_egg     <- as.data.frame(fm_egg_size) posterior_repro   <- as.data.frame(fm_reproductive_output) posterior_dev     <- as.data.frame(quadratic_counts) posterior_settle  <- as.data.frame(tiles_counts_a) posterior_recruit <- as.data.frame(tiles_counts_b)  # ======================== # 2. Posterior ratios # ========================  ## Egg size rel_pct_egg_h <- posterior_egg$b_Intercept / (posterior_egg$b_Intercept + posterior_egg$b_treatmentunimpacted) rel_pct_egg_s <- (posterior_egg$b_Intercept + posterior_egg$`b_speciesspathulatha`) /   (posterior_egg$b_Intercept + posterior_egg$`b_speciesspathulatha` +    posterior_egg$b_treatmentunimpacted + posterior_egg$`b_treatmentunimpacted:speciesspathulatha`)  ## Reproductive output rel_pct_repro_h <- posterior_repro$b_Intercept / (posterior_repro$b_Intercept + posterior_repro$b_treatmentunimpacted) rel_pct_repro_s <- (posterior_repro$b_Intercept + posterior_repro$`b_speciesspathulatha`) /   (posterior_repro$b_Intercept + posterior_repro$`b_speciesspathulatha` +    posterior_repro$b_treatmentunimpacted + posterior_repro$`b_treatmentunimpacted:speciesspathulatha`)  ## Larval development time <- 1.5 time2 <- time^2 mu_h_impacted <- posterior_dev$b_Intercept + posterior_dev$b_time * time + posterior_dev$`b_ItimeE2` * time2 mu_h_unimpacted <- mu_h_impacted + posterior_dev$b_treatmentunimpacted + posterior_dev$`b_ItimeE2:treatmentunimpacted` * time2  mu_s_impacted <- mu_h_impacted + posterior_dev$`b_speciesspathulata` + posterior_dev$`b_ItimeE2:speciesspathulata` * time2 mu_s_unimpacted <- mu_s_impacted +   posterior_dev$b_treatmentunimpacted +   posterior_dev$`b_ItimeE2:treatmentunimpacted` * time2 +   posterior_dev$`b_treatmentunimpacted:speciesspathulata` +   posterior_dev$`b_ItimeE2:treatmentunimpacted:speciesspathulata` * time2  rel_pct_dev_h <- mu_h_impacted / mu_h_unimpacted rel_pct_dev_s <- mu_s_impacted / mu_s_unimpacted  ## Settlement (pooled) rel_pct_settle <- posterior_settle$b_Intercept / (posterior_settle$b_Intercept + posterior_settle$b_treatmentunimpacted)  ## Recruitment (pooled, log-link) mu_impacted <- exp(posterior_recruit$b_Intercept) mu_unimpacted <- exp(posterior_recruit$b_Intercept + posterior_recruit$b_treatmentunimpacted) rel_pct_recruit <- mu_impacted / mu_unimpacted  # ======================== # 3. Combine and summarise # ========================  combined_draws_h <- mean(rel_pct_egg_h) * mean(rel_pct_repro_h) * mean(rel_pct_dev_h) * mean(rel_pct_settle) * mean(rel_pct_recruit) /5  combined_draws_s <- mean(rel_pct_egg_s) * mean(rel_pct_repro_s) * mean(rel_pct_dev_s) * mean(rel_pct_settle) * mean(rel_pct_recruit) /5   posterior_cumulative <- tibble(   species = c(\"hyacinthus\", \"spathulata\"),   oocyte_size = c(mean(rel_pct_egg_h), mean(rel_pct_egg_s)),   reproductive_biomass = c(mean(rel_pct_repro_h), mean(rel_pct_repro_s)),   larval_development = c(mean(rel_pct_dev_h), mean(rel_pct_dev_s)),   larval_settlement = c(mean(rel_pct_settle), mean(rel_pct_settle)),   larval_recruitment = c(mean(rel_pct_recruit), mean(rel_pct_recruit)),   cumulative_effect_size = c(mean(combined_draws_h - 1), mean(combined_draws_s - 1)),   cumulative_effect_lower = c(quantile(combined_draws_h - 1, 0.025), quantile(combined_draws_s - 1, 0.025)),   cumulative_effect_upper = c(quantile(combined_draws_h - 1, 0.975), quantile(combined_draws_s - 1, 0.975)) ) |>   mutate(across(where(is.numeric), round, 1)) |>    select(-cumulative_effect_lower, -cumulative_effect_upper)  posterior_cumulative |>   DT::datatable(     options = list(       pageLength = 5,       autoWidth = TRUE,       dom = 't',       columnDefs = list(         list(className = 'dt-center', targets = \"_all\")       )     ),     rownames = FALSE   ) %>%   DT::formatStyle(     columns = names(posterior_cumulative),     fontSize = '70%'   ) %>%   DT::formatStyle(     'species',     target = 'row',     backgroundColor = DT::styleEqual(       unique(posterior_cumulative$species),       gray.colors(length(unique(posterior_cumulative$species)), start = 0.9, end = 0.8)     )   ) #| class-source: fold-hide #| message: false #| warning: false #| fig-width: 10 #| fig-height: 2 #|    p <- (a + ggtitle(\"\") | b + ggtitle(\"\") | plot_c + ggtitle(\"\") | tileplot_a + ggtitle(\"\") | tileplot_b + ggtitle(\"\"))  ggsave(\"/Users/rof011/reefspawn/code/patchwork_plot.png\", plot = p, width = 50, height = 5, units = \"in\", dpi = 300, limitsize = FALSE)  #knitr::include_graphics(\"/Users/rof011/reefspawn/code/patchwork_plot.png\")  library(patchwork) •   1 = no effect (impacted = unimpacted) •   <1 = negative effect (impacted < unimpacted) •   >1 = positive effect (impacted > unimpacted)"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/overview.html","id":"quarto","dir":"Articles","previous_headings":"","what":"Quarto","title":"overview","text":"Quarto enables weave together content executable code finished document. learn Quarto see https://quarto.org.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/articles/overview.html","id":"running-code","dir":"Articles","previous_headings":"","what":"Running Code","title":"overview","text":"click Render button document generated includes content output embedded code. can embed code like : can add options executable code like echo: false option disables printing code (output displayed).","code":"1 + 1 [1] 2 [1] 4"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/workflow.html","id":"simulate-reef-area","dir":"Articles","previous_headings":"","what":"1) Simulate reef area","title":"Reefspawn workflow","text":"simulate reef plot 16m long 8m wide (note: default crs (EPSG:3857) projected lon/lat degrees). Colony sizes drawn posterior brms (see ?posterior_coral_predict model parameterisation details) can input survey data.","code":"library(reefspawn)  sf_plot <- setplot(16,8) # default EPSG:3857  # set up brms predictions from posterior  coralsizepredictions <- posterior_coral_predict(brm_sizedistribution, ndraws=1000, newdata=coralsize)"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/workflow.html","id":"simulate-coral-communities","dir":"Articles","previous_headings":"","what":"2) Simulate coral communities","title":"Reefspawn workflow","text":"Simulate coral communities 40% cover within 128 [m^2] plot. Communities structured 11 species across five different growthforms: tabular corals (Acropora cytherea, . hyacinthus), corymbose corals (. millepora, . nasuta, . spathulata), digitate corals (. humilis, . digitifera), branching corals (. intermedia, . robusta), massive corals (Goniastrea pectinata, G. retiformis). function builds coral communities based observed colony sizes Lizard Island 2009 2015 (~ 30 colonies 11 species, Madin et al 2023) simulates 40% cover reef. Community structure based pre-determined ratio growth forms (tabular = 0.7, digitate = 0.075, corymbose = 0.125, branching = 0.08, massive = 0.02) assigned across 11 species. exact coral cover stochastic sampled beta distribution (alpha=12, beta=4) vary ~40% cover running multiple simulations. plot = TRUE returns full summary paramterisation. details see ?reefspawn::simulate_communities()","code":"communities <- simulate_community(setplot = sf_plot,                                   coralcover=40,                                   size = coralsize,                                   ratiovar = 0.2,                                   alpha = 24,                                   beta = 8,                                   seed = 321,                                   plot = TRUE,                                   quiet = TRUE)"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/workflow.html","id":"simulate-coral-populations","dir":"Articles","previous_headings":"","what":"3) Simulate coral populations","title":"Reefspawn workflow","text":"simulated community output (% cover 11 species), simulate_populations() takes output bayesian model predictions size distributions (based Lizard Island data) simulates populations fill percent cover species. function outputs either df - dataframe individals size distribution, sf simple features corresponding sizes coordinates within initial plot. coral size data included package coralsize can replaced updated additional data flexible parameterisation. spatial mapping sf uses species hierarchy approach determining likely spatial competitor initial population space, sets maximum overlap colonies random using normal distribution (max 90% overlap) colony simulate spatially realistic coral population. spatial coordinates colony determined using circle packing algorithm within initial plot using iterative pair-wise repulsion approach find non-overlapping colonies space. approach rapid (<2 mins) small plots (<100m^2) population densities <5000 colonies, rapidly saturates becomes time consuming number - large plots subsetting smaller plots (ideally using parallel approach) computationally less taxing. output spatially referenced details see ?reefspawn::simulate_populations()","code":"populations <- simulate_populations(setplot = sf_plot,                                     size = coralsize,                                     community = communities,                                     return = \"sf\",                                     ndraws = 2000,                                     seed = 321,                                     interactive = TRUE,                                     quiet = TRUE)   head(populations) Simple feature collection with 6 features and 12 fields Active geometry column: geometry Geometry type: POLYGON Dimension:     XY Bounding box:  xmin: 3.185519 ymin: 2.155518 xmax: 15.1025 ymax: 7.32834 Projected CRS: WGS 84 / Pseudo-Mercator # A tibble: 6 × 14      id                     geometry species width   area cumulative_area aerial   <int>                <POLYGON [m]> <fct>   <dbl>  <dbl>           <dbl>  <dbl> 1     1 ((6.122144 5.793681, 6.1168… Acropo…  33.1 0.0859            859. 2.68e5 2     2 ((6.294272 6.304176, 6.2916… Acropo…  15.5 0.0189           1048. 2.68e5 3     3 ((15.1025 2.461296, 15.0928… Acropo…  55.9 0.246            3506. 2.68e5 4     4 ((13.70394 4.025407, 13.692… Acropo…  71.9 0.407            7572. 2.68e5 5     5 ((6.838162 6.869412, 6.8237… Acropo…  86.7 0.591           13480. 2.68e5 6     6 ((3.610486 6.793563, 3.6037… Acropo…  39.5 0.122           14704. 2.68e5 # ℹ 7 more variables: coords <POINT [m]>, zindex_id <int>, species.id <chr>, #   x <dbl>, y <dbl>, overlaparea <dbl>, status <chr>"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/workflow.html","id":"map-coral-populations","dir":"Articles","previous_headings":"","what":"4) Map coral populations","title":"Reefspawn workflow","text":"map_populations visualises output simulate_populations XY space. sum(populations$area) return combined area corals, (sum(populations$area) / .numeric(sum(st_area(sf_plot)))) *100 percent cover. static maps:  interactive maps: details see ?reefspawn::map_populations()","code":"map_populations(setplot = sf_plot,                 populations = populations,                 interactive = FALSE,                 webgl = TRUE) map_populations(setplot = sf_plot,                 populations = populations,                 interactive = TRUE)"},{"path":"https://marine-ecologist.github.io/reefspawn/articles/workflow.html","id":"simulate-spawning","dir":"Articles","previous_headings":"","what":"5) Simulate spawning","title":"Reefspawn workflow","text":"simulate_spawning takes colonies populations parameterises per colony output oocytes based Bayesian models fit data Lizard Island (Álvarez-Noriega et al 2016). function uses posterior_predict brms models sample draws posterior predictive distribution observed data (.e. adds model uncertainty + residual (observation-level) noise). colony, function predicts total number polyps, proportion polyps reproductive (.e. within sterile zone growth margins), number oocytes per polyp, probability colonies reproductive (binomial). Output=P⋅(⋅10,000)⋅S⋅O⋅R Output = P \\cdot (\\cdot 10{,}000) \\cdot S \\cdot O \\cdot R $:$'$- \\( P \\) = polyp density (polyps per cm²)$’ $- \\( \\) = colony area m²$'$- \\( S \\) = sterile proportion$‘$- \\( O \\) = oocytes per reproductive polyp$'$- \\( R \\) = reproductive probability$’ See brm page exact paramterisation code models. model fits included package (brm_fecundity, brm_probability, brm_polyp_density, brm_sizedistribution) can flexibly paramaterised updated data. details see ?reefspawn::simulate_spawning()  run large datasets parallel processing / mulitcore use return=\"df\"instead return=\"sf\" bypass sf functionality. Example hectare plot returns reproductive outputs 96,490 colonies 38 seconds","code":"reproductiveoutput <- simulate_spawning(populations = populations,                                         setplot = sf_plot,                                         seed = 1001,                                         quiet = FALSE,                                         plot = TRUE) [1] \"3.745 sec elapsed - simulate_populations()\" [1] \"41,833,217 - total reproductive output\" [1] \"326,822 - reproductive output per m2\" sf_plot_large <- setplot(100,100)     hectare_output <- simulate_community(setplot = sf_plot_large,                                       coralcover=40,                                       size = coralsize |> dplyr::filter(year==2011),                                       seed = 321,                                       plot = FALSE,                                       quiet = TRUE) %>%                  simulate_populations(community = .,                                       seed = 321,                                       return=\"df\") %>%                 simulate_spawning(populations = .,                                    seed = 321)   hectare_summary <- hectare_output |>   dplyr::group_by(species) |>   dplyr::summarise(output = sum(output)) |>   dplyr::mutate(output = format(output, big.mark = \",\", scientific = FALSE)) %>%   dplyr::bind_rows(     dplyr::summarise(., species = \"Total\", output = format(sum(as.numeric(gsub(\",\", \"\", output))), big.mark = \",\"))   )     reactable::reactable(   head(hectare_summary, 20),   defaultPageSize = 20,   pagination = FALSE,   searchable = FALSE,   highlight = TRUE,   bordered = TRUE,   striped = TRUE )"},{"path":"https://marine-ecologist.github.io/reefspawn/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"George Roff. Author, maintainer.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Roff G (2025). reefspawn: Community scale simulations coral reproductive output. R package version 0.0.0.9000, https://marine-ecologist.github.io/reefspawn.","code":"@Manual{,   title = {reefspawn: Community scale simulations of coral reproductive output},   author = {George Roff},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://marine-ecologist.github.io/reefspawn}, }"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/beta_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample Beta Distribution and Return Density — beta_dist","title":"Sample Beta Distribution and Return Density — beta_dist","text":"Generates beta distribution based specified mean variance, returns density estimate data frame.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/beta_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample Beta Distribution and Return Density — beta_dist","text":"","code":"beta_dist(mean, variance, samples = 1000, variance_factor = 0.1)"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/beta_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample Beta Distribution and Return Density — beta_dist","text":"mean Numeric scalar. Desired mean beta distribution. Must 0 1 (exclusive). variance Numeric scalar. Desired variance beta distribution. constrained variance_factor. samples Integer. Number samples draw beta distribution. Default 1000. variance_factor Numeric scalar. Limits allowed variance fraction theoretical maximum variance. Default 0.1.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/beta_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample Beta Distribution and Return Density — beta_dist","text":"tibble columns x y representing smoothed density estimate sampled beta distribution.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/beta_dist.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sample Beta Distribution and Return Density — beta_dist","text":"shape (.e., skew peak) Beta distribution driven ratio alpha / (alpha + beta) (controls mean), sum alpha + beta (controls concentration/peakedness).","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/beta_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample Beta Distribution and Return Density — beta_dist","text":"","code":"beta_dist(mean = 0.4, variance = 0.01) #> # A tibble: 512 × 2 #>         x        y #>     <dbl>    <dbl> #>  1 0.0891 0.000358 #>  2 0.0905 0.000431 #>  3 0.0918 0.000517 #>  4 0.0931 0.000620 #>  5 0.0944 0.000743 #>  6 0.0957 0.000886 #>  7 0.0971 0.00105  #>  8 0.0984 0.00124  #>  9 0.0997 0.00147  #> 10 0.101  0.00174  #> # ℹ 502 more rows"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/calculate_allee_effects.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Within-Species Pairwise Colony Distances with Status Label — calculate_allee_effects","title":"Calculate Within-Species Pairwise Colony Distances with Status Label — calculate_allee_effects","text":"Computes centroid--centroid, edge--edge, max-distance metrics colonies within species, returns single combined data frame status column indicating source subset.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/calculate_allee_effects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Within-Species Pairwise Colony Distances with Status Label — calculate_allee_effects","text":"","code":"calculate_allee_effects(   populations,   metric = \"centroid_distance\",   label,   dist = Inf,   ... )"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/calculate_allee_effects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Within-Species Pairwise Colony Distances with Status Label — calculate_allee_effects","text":"populations sf object columns: id, species, status, width, geometry.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/calculate_allee_effects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Within-Species Pairwise Colony Distances with Status Label — calculate_allee_effects","text":"single tibble columns: species, id_from, id_to, centroid_distance, colony_distance, max_distance, status.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/calculate_egg_densities.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate volumetric density of spheres with percent surface cover — calculate_egg_densities","title":"Calculate volumetric density of spheres with percent surface cover — calculate_egg_densities","text":"Computes number spheres per cubic meter percent cover, total area (cm²), sphere diameter (µm), depth (mm). Converts units SI. Supports idealized layered 3D packing.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/calculate_egg_densities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate volumetric density of spheres with percent surface cover — calculate_egg_densities","text":"","code":"calculate_egg_densities(   diameter_um,   surface_percent_cover,   depth_mm,   cover_area = 67.92909,   packing_efficiency = 0.74048,   method = c(\"3d_packing\", \"layered\") )"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/calculate_egg_densities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate volumetric density of spheres with percent surface cover — calculate_egg_densities","text":"diameter_um Numeric. Sphere diameter microns (µm). surface_percent_cover Numeric. Percent cover (0–100). depth_mm Numeric. Depth packed layer (mm). packing_efficiency Numeric. Packing efficiency (default: 0.74048). method Character. One \"3d_packing\" (default) \"layered\". cover_area_cm2 Numeric. Total substrate area (cm²).","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/calculate_egg_densities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate volumetric density of spheres with percent surface cover — calculate_egg_densities","text":"Numeric. Sphere density spheres per m³.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/calculate_egg_densities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate volumetric density of spheres with percent surface cover — calculate_egg_densities","text":"","code":"calculate_egg_densities(500, 100, 2, method = \"3d_packing\") #> [1] 11313701017 calculate_egg_densities(500, 100, 2, method = \"layered\") #> [1] 10185916358"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/calculate_intraspecific_allee_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Intraspecific Pairwise Colony Distances as sf LINESTRINGs — calculate_intraspecific_allee_dist","title":"Calculate Intraspecific Pairwise Colony Distances as sf LINESTRINGs — calculate_intraspecific_allee_dist","text":"Computes intraspecific pairwise distances coral colony centroids derives edge--edge maximum distances. Results returned sf LINESTRINGs connecting colony centroids.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/calculate_intraspecific_allee_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Intraspecific Pairwise Colony Distances as sf LINESTRINGs — calculate_intraspecific_allee_dist","text":"","code":"calculate_intraspecific_allee_dist(subset, label, ...)"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/calculate_intraspecific_allee_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Intraspecific Pairwise Colony Distances as sf LINESTRINGs — calculate_intraspecific_allee_dist","text":"subset sf object polygon geometries, columns species, id, width (diameter cm). label character label (e.g. \"bleached\", \"unbleached\") annotate line.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/calculate_intraspecific_allee_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Intraspecific Pairwise Colony Distances as sf LINESTRINGs — calculate_intraspecific_allee_dist","text":"sf object LINESTRINGs columns: species Species name. id_from ID origin colony. id_to ID target colony. centroid_distance Distance colony centroids (CRS units). colony_distance Edge--edge distance (centroid distance minus radii). max_distance Maximum distance including radii. status Label passed label argument.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/calculate_intraspecific_allee_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Intraspecific Pairwise Colony Distances as sf LINESTRINGs — calculate_intraspecific_allee_dist","text":"","code":"if (FALSE) { # \\dontrun{ calculate_intraspecific_allee_dist(coral_sf, label = \"unbleached\") } # }"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/coralsim.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Coral Colonies in a Polygon — coralsim","title":"Simulate Coral Colonies in a Polygon — coralsim","text":"function simulates coral cover colony distribution within specified polygon. generates species-specific ratios, predicts coral colony sizes, uses spatial algorithms distribute colonies without overlap.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/coralsim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Coral Colonies in a Polygon — coralsim","text":"","code":"coralsim(input, set_overlap, raw = FALSE, seed = NULL, crs = 3857, ...)"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/coralsim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Coral Colonies in a Polygon — coralsim","text":"input sf polygon object defining plot area. set_overlap percentage overlap setting colonies (randomized). raw Logical. TRUE, returns raw data instead spatial polygons. seed optional seed value reproducibility. crs coordinate reference system (default EPSG:3857). ... Additional arguments passed underlying functions.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/coralsim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Coral Colonies in a Polygon — coralsim","text":"sf object containing non-overlapping coral colony polygons, raw data raw = TRUE.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/fecundity.html","id":null,"dir":"Reference","previous_headings":"","what":"Load and preprocess coral fecundity and size data — fecundity","title":"Load and preprocess coral fecundity and size data — fecundity","text":"Loads fecundity.csv size_structure.csv inst/extdata directory, computes derived width area, assigns species-level growthforms.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/fecundity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load and preprocess coral fecundity and size data — fecundity","text":"","code":"fecundity"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/fecundity.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Load and preprocess coral fecundity and size data — fecundity","text":"object class data.frame 32436 rows 13 columns.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/fecundity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load and preprocess coral fecundity and size data — fecundity","text":"Two data frames: fecundity: colony area, width, reproductive status coralsize: species, width, assigned growthform","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/fecundity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Load and preprocess coral fecundity and size data — fecundity","text":"fecundity includes colony-level reproductive data. coralsize contains colony size structure species, growthform classification. Width computed sqrt(area_cm2 / pi) * 2. Growthforms assigned using fct_recode() based species identity.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/fecundity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load and preprocess coral fecundity and size data — fecundity","text":"","code":"head(fecundity) #>         id year observer              species spp colony branch polyp eggs #> 1 F10_GP01 2016       CY Goniastrea pectinata  GP      1     NA     4    0 #> 2 F10_GP01 2016       CY Goniastrea pectinata  GP      1     NA     2    0 #> 3 F10_GP01 2016       CY Goniastrea pectinata  GP      1     NA     1    0 #> 4 F10_GP01 2016       CY Goniastrea pectinata  GP      1     NA     3    0 #> 5 F10_GP01 2016       CY Goniastrea pectinata  GP      1     NA     6    0 #> 6 F10_GP01 2016       CY Goniastrea pectinata  GP      1     NA     5    0 #>   area_cm2 reproductive       area    width #> 1  43.5185            0 0.00435185 7.443754 #> 2  43.5185            0 0.00435185 7.443754 #> 3  43.5185            0 0.00435185 7.443754 #> 4  43.5185            0 0.00435185 7.443754 #> 5  43.5185            0 0.00435185 7.443754 #> 6  43.5185            0 0.00435185 7.443754 head(coralsize) #>   spp               species year  area_cm2     width growthform #> 1  GR Goniastrea retiformis 2010  12.27814  3.953861    Massive #> 2  GR Goniastrea retiformis 2010  91.45160 10.790727    Massive #> 3  AH   Acropora hyacinthus 2010  19.80796  5.021979    Tabular #> 4  AL   Acropora spathulata 2010 210.93766 16.388233  Corymbose #> 5  GR Goniastrea retiformis 2010 330.54733 20.515017    Massive #> 6  AS      Acropora humilis 2010 113.80219 12.037335   Digitate"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/map_populations.html","id":null,"dir":"Reference","previous_headings":"","what":"Map Coral Populations with Species Coloring — map_populations","title":"Map Coral Populations with Species Coloring — map_populations","text":"Plots spatial map coral populations setplot base layer using tmap. Species color-coded customizable palette, output can either interactive (web) static. Optionally enables disables WebGL 3D rendering interactive view.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/map_populations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map Coral Populations with Species Coloring — map_populations","text":"","code":"map_populations(   setplot,   populations,   interactive = TRUE,   zoom = c(22, 32),   webgl = TRUE )"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/map_populations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map Coral Populations with Species Coloring — map_populations","text":"setplot sf SpatVector object representing background plot layer (e.g. reef tiles). populations sf object point geometries species column map. interactive Logical; TRUE, map shown interactive web view. FALSE, renders static plot. webgl Logical; interactive = TRUE, sets WebGL rendering mode tm_view().","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/map_populations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map Coral Populations with Species Coloring — map_populations","text":"tmap object","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/map_populations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map Coral Populations with Species Coloring — map_populations","text":"","code":"if (FALSE) { # \\dontrun{ grid <- setplot(10, 5) map_populations(setplot = grid, populations = coral_points, interactive = TRUE, webgl = FALSE) } # }"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/polyp_density_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Load and augment coral polyp density data — polyp_density_data","title":"Load and augment coral polyp density data — polyp_density_data","text":"Loads polyp_density.csv, adds estimated entry Acropora millepora based similar species (. nasuta . spathulata), assigns growthform classifications.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/polyp_density_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load and augment coral polyp density data — polyp_density_data","text":"","code":"polyp_density_data"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/polyp_density_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Load and augment coral polyp density data — polyp_density_data","text":"object class data.frame 45 rows 7 columns.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/polyp_density_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load and augment coral polyp density data — polyp_density_data","text":"polyp_density_data data frame species assigned growthforms.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/polyp_density_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Load and augment coral polyp density data — polyp_density_data","text":"Acropora millepora present original dataset. estimate , data . nasuta . spathulata duplicated relabeled. new spp code \"\" assigned added entries. Growthforms recoded using fct_recode() based species name.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/polyp_density_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load and augment coral polyp density data — polyp_density_data","text":"","code":"head(polyp_density_data) #>         id spp              species cm2 polyps polyps_cm2 growthform #> 1      764  AC    Acropora cytherea  16   1268    79.2500    Tabular #> 2      663  AH  Acropora hyacinthus  16   1355    84.6875    Tabular #> 3      719  AH  Acropora hyacinthus  16   1212    75.7500    Tabular #> 4 large G.  GP Goniastrea pectinata  16     90     5.6250    Massive #> 5      769  GP Goniastrea pectinata  16     57     3.5625    Massive #> 6      733  GP Goniastrea pectinata  16    112     7.0000    Massive"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/posterior_coral_predict.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Posterior Predictions of Coral Colony Area — posterior_coral_predict","title":"Generate Posterior Predictions of Coral Colony Area — posterior_coral_predict","text":"function uses fitted brms model generate posterior predictions colony size (width), transforms width area, returns cumulative area predictions per species long format.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/posterior_coral_predict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Posterior Predictions of Coral Colony Area — posterior_coral_predict","text":"","code":"posterior_coral_predict(   brms,   ndraws = 10000,   seed = NULL,   newdata,   correct_species = FALSE )"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/posterior_coral_predict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Posterior Predictions of Coral Colony Area — posterior_coral_predict","text":"brms fitted brms model predicting colony width. ndraws Integer. Number posterior draws sample. newdata data frame containing predictor variables prediction. correct_species Logical. Whether rename \"Acropora cf. digitifera\" \"Acropora digitifera\" predictions.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/posterior_coral_predict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Posterior Predictions of Coral Colony Area — posterior_coral_predict","text":"tibble posterior draws long format, including species, width, area, cumulative area.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_colony_width.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict colony width using posterior predict (lognormal model) — predict_colony_width","title":"Predict colony width using posterior predict (lognormal model) — predict_colony_width","text":"Predict colony width using posterior predict (lognormal model)","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_colony_width.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict colony width using posterior predict (lognormal model) — predict_colony_width","text":"","code":"predict_colony_width(newdata, draws, draw_id = 1)"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_colony_width.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict colony width using posterior predict (lognormal model) — predict_colony_width","text":"newdata data.frame species column. draws Posterior draws posterior_coeffs_sizedistribution. draw_id Integer index draw use.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_colony_width.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict colony width using posterior predict (lognormal model) — predict_colony_width","text":"Numeric vector predicted widths.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_colony_width.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict colony width using posterior predict (lognormal model) — predict_colony_width","text":"","code":"if (FALSE) { # \\dontrun{ newdata <- data.frame(species = c(\"Acropora\", \"Porites\")) predict_colony_width(newdata, posterior_coeffs_sizedistribution, draw_id = 10) } # }"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_oocytes.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict oocytes per reproductive polyp using posterior predict (ZIP model) — predict_oocytes","title":"Predict oocytes per reproductive polyp using posterior predict (ZIP model) — predict_oocytes","text":"Predict oocytes per reproductive polyp using posterior predict (ZIP model)","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_oocytes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict oocytes per reproductive polyp using posterior predict (ZIP model) — predict_oocytes","text":"","code":"predict_oocytes(newdata, draws, draw_id = 1)"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_oocytes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict oocytes per reproductive polyp using posterior predict (ZIP model) — predict_oocytes","text":"newdata data.frame species width columns. draws Posterior draws posterior_coeffs_oocyte_output. draw_id Integer index draw use.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_oocytes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict oocytes per reproductive polyp using posterior predict (ZIP model) — predict_oocytes","text":"Numeric vector expected counts.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_oocytes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict oocytes per reproductive polyp using posterior predict (ZIP model) — predict_oocytes","text":"","code":"if (FALSE) { # \\dontrun{ newdata <- expand.grid(species = levels(coralsize$species), width = seq(0,50,5)) newdata$oocytes <- predict_oocytes(newdata, posterior_coeffs_oocyte_output, draw_id = 100) } # }"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_polyp_density.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict polyp density per colony using posterior predict (gaussian model) — predict_polyp_density","title":"Predict polyp density per colony using posterior predict (gaussian model) — predict_polyp_density","text":"Predict polyp density per colony using posterior predict (gaussian model)","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_polyp_density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict polyp density per colony using posterior predict (gaussian model) — predict_polyp_density","text":"","code":"predict_polyp_density(newdata, draws, draw_id = 1)"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_polyp_density.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict polyp density per colony using posterior predict (gaussian model) — predict_polyp_density","text":"newdata data.frame species column. draws Posterior draws posterior_coeffs_polypdensity. draw_id Integer index draw use.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_polyp_density.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict polyp density per colony using posterior predict (gaussian model) — predict_polyp_density","text":"Numeric vector predicted polyp densities.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_polyp_density.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict polyp density per colony using posterior predict (gaussian model) — predict_polyp_density","text":"","code":"if (FALSE) { # \\dontrun{ newdata <- data.frame(species = c(\"Acropora\", \"Porites\")) predict_polyp_density(newdata, posterior_coeffs_polypdensity, draw_id = 5) } # }"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_repro_prob.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict reproductive probability using posterior predict (bernoulli model) — predict_repro_prob","title":"Predict reproductive probability using posterior predict (bernoulli model) — predict_repro_prob","text":"Predict reproductive probability using posterior predict (bernoulli model)","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_repro_prob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict reproductive probability using posterior predict (bernoulli model) — predict_repro_prob","text":"","code":"predict_repro_prob(newdata, draws, draw_id = 1)"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_repro_prob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict reproductive probability using posterior predict (bernoulli model) — predict_repro_prob","text":"newdata data.frame species width columns. draws Posterior draws posterior_coeffs_reproductive_probability. draw_id Integer index draw use.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_repro_prob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict reproductive probability using posterior predict (bernoulli model) — predict_repro_prob","text":"Numeric vector probabilities.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/predict_repro_prob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict reproductive probability using posterior predict (bernoulli model) — predict_repro_prob","text":"","code":"if (FALSE) { # \\dontrun{ newdata <- expand.grid(species = levels(coralsize$species), width = seq(0,50,5)) newdata$reproductive_probability <- predict_repro_prob(newdata, posterior_coeffs_reproductive_probability, draw_id = 20) } # }"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/reefspawn-package.html","id":null,"dir":"Reference","previous_headings":"","what":"reefspawn: Community scale simulations of coral reproductive output — reefspawn-package","title":"reefspawn: Community scale simulations of coral reproductive output — reefspawn-package","text":"Functions scale coral reproductive output spawning Indo-Pacific corals","code":""},{"path":[]},{"path":"https://marine-ecologist.github.io/reefspawn/reference/reefspawn-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"reefspawn: Community scale simulations of coral reproductive output — reefspawn-package","text":"Maintainer: George Roff george.roff@csiro.au","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/sample_sterile_zone.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample Sterile Zone Proportions by Species — sample_sterile_zone","title":"Sample Sterile Zone Proportions by Species — sample_sterile_zone","text":"Returns vector sterile zone proportions (.e., proportion coral colony lies outside sterile zone), sampled lower, median, upper estimates per species.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/sample_sterile_zone.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample Sterile Zone Proportions by Species — sample_sterile_zone","text":"","code":"sample_sterile_zone(   species_vec,   width_vec = NULL,   draw = c(\"random\", \"median\", \"lower\", \"upper\") )"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/sample_sterile_zone.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample Sterile Zone Proportions by Species — sample_sterile_zone","text":"species_vec character vector species names. width_vec Optional numeric vector colony widths (ignored; reserved future use). draw Character, one \"random\" (default), \"median\", \"lower\", \"upper\". Determines select sterile proportion value.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/sample_sterile_zone.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample Sterile Zone Proportions by Species — sample_sterile_zone","text":"numeric vector sampled sterile zone proportions, length species_vec.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/sample_sterile_zone.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample Sterile Zone Proportions by Species — sample_sterile_zone","text":"","code":"if (FALSE) { # \\dontrun{ species <- c(\"Acropora hyacinthus\", \"Acropora millepora\", \"Goniastrea retiformis\") sample_sterile_zone(species, draw = \"random\") } # }"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/setplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a Rectangular sf Plot Grid — setplot","title":"Generate a Rectangular sf Plot Grid — setplot","text":"Creates simple rectangular spatial plot specified length width meters, returns 1m x 1m sf grid overlaid area. CRS EPSG:3857 default.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/setplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a Rectangular sf Plot Grid — setplot","text":"","code":"setplot(length, width, crs = 3857, quiet = TRUE)"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/setplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a Rectangular sf Plot Grid — setplot","text":"length Numeric. Length plot meters (X-dimension). width Numeric. Width plot meters (Y-dimension). crs Integer. Coordinate Reference System (default = 3857).","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/setplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a Rectangular sf Plot Grid — setplot","text":"sf object representing grid 1m x 1m cells covering defined plot.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/setplot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a Rectangular sf Plot Grid — setplot","text":"","code":"grid <- setplot(10, 5) plot(grid)"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_bleaching.html","id":null,"dir":"Reference","previous_headings":"","what":"Assign Bleaching Status to Coral Population — simulate_bleaching","title":"Assign Bleaching Status to Coral Population — simulate_bleaching","text":"Randomly assigns bleaching status (\"bleached\" \"unbleached\") individuals population dataset based species-specific mortality rates.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_bleaching.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assign Bleaching Status to Coral Population — simulate_bleaching","text":"","code":"simulate_bleaching(   populations,   mortality = NULL,   seed,   silent = FALSE,   plot = FALSE )"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_bleaching.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assign Bleaching Status to Coral Population — simulate_bleaching","text":"mortality data frame columns species mortality (values 0 1). population sf object species column.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_bleaching.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assign Bleaching Status to Coral Population — simulate_bleaching","text":"sf object additional column status.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_community.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Coral Community Composition — simulate_community","title":"Simulate Coral Community Composition — simulate_community","text":"Generates simulated coral community composition allocating aerial cover species based user-defined morphological ratios total coral cover estimate, optionally drawn beta distribution. Optionally plots species size distributions assigned ratios.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_community.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Coral Community Composition — simulate_community","text":"","code":"simulate_community(   setplot,   size,   ratio,   ratiovar = 0.2,   coralcover = NULL,   distribution = \"beta\",   alpha = 12,   beta = 4,   seed = NULL,   quiet = TRUE,   plot = FALSE,   ... )"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_community.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Coral Community Composition — simulate_community","text":"setplot sf polygon object representing plot area (used calculate total area). size data frame columns species area_cm2 containing size distributions. ratio named numeric vector proportions assigned growth form (names must : \"Tabular\", \"Branching\", \"Corymbose\", \"Digitate\", \"Massive\"). ratiovar Numeric. Proportional noise added growthform's ratio. Default 0.2. coralcover Numeric. Mean coral cover percentage (0–100). distribution = \"beta\", mean used sample actual coral cover. distribution Character. \"beta\", coral cover sampled beta distribution. Set NULL use coralcover directly. alpha Shape parameter α beta distribution (default = 12). beta Shape parameter β beta distribution (default = 4). seed Optional. integer seed reproducible randomization. quiet verbose plot Logical. TRUE, generates diagnostic plots simulation distributions. ... Additional arguments (currently ignored).","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_community.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Coral Community Composition — simulate_community","text":"data frame (tibble) columns species, growthform, ratio, cover, aerial area per species cm².","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_community.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Coral Community Composition — simulate_community","text":"","code":"if (FALSE) { # \\dontrun{ ratios <- c(Tabular = 0.2, Branching = 0.2, Corymbose = 0.2, Digitate = 0.2, Massive = 0.2) simulate_community(setplot = my_sf_plot, size = coral_size_data, ratio = ratios, coralcover = 30) } # }"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_coralsize.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Coral Colony Sizes Using Skewed Distributions — simulate_coralsize","title":"Simulate Coral Colony Sizes Using Skewed Distributions — simulate_coralsize","text":"function simulates coral colony sizes per species using either log-normal (rlnorm) gamma (rgamma) distribution, based observed mean standard deviation colony widths input data. species sampled ndraws times.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_coralsize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Coral Colony Sizes Using Skewed Distributions — simulate_coralsize","text":"","code":"simulate_coralsize(   input = coralsize,   distribution = \"rlnorm\",   ndraws,   plot = FALSE,   seed = NULL )"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_coralsize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Coral Colony Sizes Using Skewed Distributions — simulate_coralsize","text":"input data frame columns species width. Default coralsize. distribution Character string. Distribution type simulate . Supported options \"rlnorm\" \"gamma\". ndraws Integer. Number simulated coral sizes per species. plot Logical. TRUE, histogram simulated sizes plotted species. seed Optional integer. provided, sets random seed reproducibility.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_coralsize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Coral Colony Sizes Using Skewed Distributions — simulate_coralsize","text":"tibble columns: species Factor indicating coral species width Simulated colony width values area_cm2 Simulated colony area values (π × (width/2)²)","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_populations.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Coral Population Layout from Posterior Predictions — simulate_populations","title":"Simulate Coral Population Layout from Posterior Predictions — simulate_populations","text":"Generates spatial coral population layout drawing brms-fit model colony sizes, filtering match aerial coverage constraints, laying colonies optional circle packing.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_populations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Coral Population Layout from Posterior Predictions — simulate_populations","text":"","code":"simulate_populations(   setplot,   size,   community,   posterior = coralsizepredictions,   return = \"df\",   algorithm = \"repel\",   ndraws = 20000,   maxiter = 100,   seed = NULL,   quiet = TRUE,   ... )"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_populations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Coral Population Layout from Posterior Predictions — simulate_populations","text":"setplot sf polygon representing area colonies positioned. size data frame containing species size distribution (area width). community data frame containing species aerial (m²) coverage values. posterior return posterior_coral_predict colony size species. return Character. \"df\" returns raw colony list; \"sf\" returns spatial polygons. Default: \"df\". algorithm Character. \"repel\" (default) \"progressive\" — determines circle packing layout method. ndraws Integer. Number posterior predictive draws simulate. Default: 50000. seed Optional integer reproducibility sampling layout. quiet verbose","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_populations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Coral Population Layout from Posterior Predictions — simulate_populations","text":"Either data frame simulated colonies (df) sf object spatial polygons (sf) depending return.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_populations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Coral Population Layout from Posterior Predictions — simulate_populations","text":"Species names harmonized using fct_recode. Aerial coverage enforced using cumulative area filtering. circleRepelLayout() uses iterative physics-based algorithm, circleProgressiveLayout() faster approximate. Coordinates assigned using sf::st_sample() radii scaled match overlap assumptions.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_populations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Coral Population Layout from Posterior Predictions — simulate_populations","text":"","code":"if (FALSE) { # \\dontrun{ simulate_populations(setplot = myreef_sf, size = colony_data, community = community_df,                      brms = size_model, return = \"sf\", algorithm = \"repel\", seed = 42, plot = TRUE) } # }"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_spawning.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Spawning Output per Coral Colony — simulate_spawning","title":"Simulate Spawning Output per Coral Colony — simulate_spawning","text":"Combines multiple Bayesian models estimate reproductive output (number oocytes) colony population. Uses polyp density, reproductive probability, sterile zone proportion, oocytes per polyp.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_spawning.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Spawning Output per Coral Colony — simulate_spawning","text":"","code":"simulate_spawning(populations, setplot, seed, quiet = TRUE, plot = FALSE, ...)"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_spawning.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Spawning Output per Coral Colony — simulate_spawning","text":"populations sf object containing colony data species, width, area columns. setplot setplot area seed setseed. quiet verbose plot plot output?","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/simulate_spawning.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Spawning Output per Coral Colony — simulate_spawning","text":"modified populations sf object added columns: polypdensity: Predicted polyps per cm² repro_prob: Probability reproductive sterile_proportion: Proportion outside sterile zone oocytes: Oocytes per reproductive polyp colony_polyps: Total number polyps per colony reproductive_polyps: Number reproductive polyps sterile_polyps: Number sterile polyps output: Total reproductive output (reproductive polyps × oocytes)","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/sp_order.html","id":null,"dir":"Reference","previous_headings":"","what":"Load and preprocess coral fecundity and size data — sp_order","title":"Load and preprocess coral fecundity and size data — sp_order","text":"Loads fecundity.csv size_structure.csv inst/extdata directory, computes derived width area, assigns species-level growthforms.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/sp_order.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load and preprocess coral fecundity and size data — sp_order","text":"","code":"sp_order"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/sp_order.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Load and preprocess coral fecundity and size data — sp_order","text":"object class character length 11.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/sp_order.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load and preprocess coral fecundity and size data — sp_order","text":"Two data frames: fecundity: colony area, width, reproductive status coralsize: species, width, assigned growthform","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/sp_order.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Load and preprocess coral fecundity and size data — sp_order","text":"fecundity includes colony-level reproductive data. coralsize contains colony size structure species, growthform classification. Width computed sqrt(area_cm2 / pi) * 2. Growthforms assigned using fct_recode() based species identity.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/sp_order.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load and preprocess coral fecundity and size data — sp_order","text":"","code":"if (FALSE) { # \\dontrun{ head(fecundity) head(coralsize) } # }"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/sp_pal.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Species Color Palette — sp_pal","title":"Generate Species Color Palette — sp_pal","text":"Returns named vector hex color codes coral species, option lighten palette alternate display modes (e.g., backgrounds emphasis).","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/sp_pal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Species Color Palette — sp_pal","text":"","code":"sp_pal(type = \"base\")"},{"path":"https://marine-ecologist.github.io/reefspawn/reference/sp_pal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Species Color Palette — sp_pal","text":"type Character. Type palette return. \"base\" default palette, value return paler variant.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/sp_pal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Species Color Palette — sp_pal","text":"named character vector names species names values hex color codes.","code":""},{"path":"https://marine-ecologist.github.io/reefspawn/reference/sp_pal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Species Color Palette — sp_pal","text":"","code":"sp_pal()                        # Returns base palette #>     Acropora hyacinthus       Acropora cytherea     Acropora intermedia  #>               \"#50676c\"               \"#3a6c8e\"               \"#2c3687\"  #>        Acropora robusta     Acropora spathulata      Acropora millepora  #>               \"#7b8ca8\"               \"#98a062\"               \"#665a43\"  #>         Acropora nasuta        Acropora humilis Acropora cf. digitifera  #>               \"#48642f\"               \"#824b3b\"               \"#a47c73\"  #>    Goniastrea pectinata   Goniastrea retiformis  #>               \"#999999\"               \"#bfbfbf\"  sp_pal(\"pale\")                 # Returns lighter palette #>     Acropora hyacinthus       Acropora cytherea     Acropora intermedia  #>             \"#607C82FF\"             \"#4682AAFF\"             \"#3541A2FF\"  #>        Acropora robusta     Acropora spathulata      Acropora millepora  #>             \"#94A8CAFF\"             \"#B6C076FF\"             \"#7A6C50FF\"  #>         Acropora nasuta        Acropora humilis Acropora cf. digitifera  #>             \"#567838FF\"             \"#9C5A47FF\"             \"#C5958AFF\"  #>    Goniastrea pectinata   Goniastrea retiformis  #>             \"#B8B8B8FF\"             \"#E5E5E5FF\"  barplot(rep(1, 11), col = sp_pal())  # Visualize palette"}]
